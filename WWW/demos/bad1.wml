#include '$(PDLROOT)/templates/header.wml'
<lang:star:slice: bad1_*.html>

<comment> ---------------------------------------------------------- </comment>
<HEAD*>
<META* HTTP-EQUIV = "KEYWORDS" 
       CONTENT    = "Schwebel"
>
<META* NAME       = "DESCRIPTION" 
       CONTENT    = "Robert Schwebel"
>
<TITLE*>PDL - Screenshots / Demos</TITLE*>
</HEAD*>
<comment> ---------------------------------------------------------- </comment>

<set-var doctype=html>

#include '$(PDLROOT)/templates/top.wml'
#include '$(PDLROOT)/menue.wml'

<!-- ---------------------------------------------------------------------- -->

<HR>

<EN><H2> Tour of the bad value support in PDL </H2></EN>
<DE><H2> Einführung zu "bad values" in PDL</H2></DE>

<en-p>
Each piddle contains a flag - accessible via the badflag() method - 
which indicates whether:
</en-p>

<de-p>
In jeder PDL-Variable gibt es ein Flag (erreichbar über die
badflag()-Funktion), das folgendes besagt:
</de-p>

<!-- ----- -->

<en-p>
&nbsp;&nbsp;&nbsp;       the piddle contains no bad values (flag equals 0)<BR>
&nbsp;&nbsp;&nbsp;       the piddle *MAY* contain bad values (flag equals 1)<BR>
</en-p>

<de-p>
&nbsp;&nbsp;&nbsp;       Im piddle sind keine "bad values" vorhanden: Flag ist 0<BR>
&nbsp;&nbsp;&nbsp;       Das piddle *kann* "bad values" beinhalten: Flag ist 1<BR>
</de-p>

<!-- ----- -->

<en-p>
If the flag is set, then the routines (well, those that have been
converted) will process these bad values correctly, otherwise they 
are ignored. 
</en-p>

<de-p>
Ist das Flag gesetzt, können die Routienen, die bereits "bad values"
unterstützen, korrekt mit diesen umgehen. Andernfalls werden sie ignoriert.
</de-p>

<!-- ----- -->

<en-p>
The code has been written so as to provide as little overhead as
possible; therefore there should be almost no difference in the
time it takes to process piddles which do not have their bad flag 
set.
</en-p>

<de-p>
Der Code wurde so implementiert, daß durch den "bad value"-Support möglichst
wenig zusätzlicher Aufwand erzeugt wird; dadurch sollte bei piddles, bei denen
das Flag nicht gesetzt ist, nahezu kein Performanceunterschied spürbar sein. 
</de-p>

<!-- ----- -->

<PRE>
<CODE>
<FONT COLOR="RED"># There are 2 ways to see whether bad-value support has been</FONT>
<FONT COLOR="RED"># compiled into your perldl:</FONT>
<STRONG>perldl></STRONG> print("You can use bad values.\n") if $PDL::Bad::Status;
<FONT COLOR="RED"># or</FONT>
<STRONG>perldl></STRONG> use PDL::Config;
<STRONG>perldl></STRONG> print("You can stil use bad values.\n") if $PDL::Config{WITH_BADVAL};
<FONT COLOR="RED"># note that PDL::Bad is included by default when you use </FONT>
<FONT COLOR="RED"># 'use PDL', 'use PDL::Lite', or 'use PDL::LiteF'</FONT>

You can use bad values.
You can stil use bad values.
</CODE>
</PRE>

<!-- ----- -->

<PRE>
<CODE>
<FONT COLOR="RED"># create a piddle</FONT>
<STRONG>perldl></STRONG> $a = byte(1,2,3);
<STRONG>perldl></STRONG> print( "Bad flag (a) == ", $a->badflag(), "\n" );
<FONT COLOR="RED"># set bad flag, even though all the data is good</FONT>
<STRONG>perldl></STRONG> $a->badflag(1);
<STRONG>perldl></STRONG> print( "Bad flag (a) == ", $a->badflag(), "\n" );
<FONT COLOR="RED"># note the bad flag is infectious</FONT>
<STRONG>perldl></STRONG> $b = 2 * $a;
<STRONG>perldl></STRONG> print( "Bad flag (b) == ", $b->badflag(), "\n\n" );

Bad flag (a) == 0
Bad flag (a) == 1
Bad flag (b) == 1

</CODE>
</PRE>

<!-- ----- -->

<PRE>
<CODE>
<FONT COLOR="RED"># the badflag is also included in the state info of</FONT>
<FONT COLOR="RED"># piddle</FONT>
<FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> $c = pdl(2,3); # just a piddle without the badflag set
<STRONG>perldl></STRONG> print "   Type   Dimension        State          Mem\n";
<STRONG>perldl></STRONG> print "-------------------------------------------------\n";
<STRONG>perldl></STRONG> print "a ", $a->info("%-6T %-15D   %-5S  %12M"), "\n";
<STRONG>perldl></STRONG> print "b ", $b->info("%-6T %-15D   %-5S  %12M"), "\n";
<STRONG>perldl></STRONG> print "c ", $c->info("%-6T %-15D   %-5S  %12M"), "\n\n";

   Type   Dimension        State          Mem
-------------------------------------------------
a Byte   D [3]             PB           0.00Kb
b Byte   D [3]             PB           0.00Kb
c Double D [2]             P            0.02Kb

</CODE>
</PRE>

<!-- ----- -->

<PRE>
<CODE>
<STRONG>perldl></STRONG> print "No bad values:   $a\n";
<FONT COLOR="RED"># set the middle value bad</FONT>
<STRONG>perldl></STRONG> $a->setbadat(1);
<FONT COLOR="RED"># now print out</FONT>
<STRONG>perldl></STRONG> print "Some bad values: $a\n";
<STRONG>perldl></STRONG> print "b contains:      $b\n";
<STRONG>perldl></STRONG> $c = $a + $b;
<STRONG>perldl></STRONG> print "so a + b =       $c\n\n";

No bad values:   [1 2 3]
Some bad values: [1 BAD 3]
b contains:      [2 4 6]
so a + b =       [3 BAD 9]

</CODE>
</PRE>

<!-- ----- -->

<PRE>
<CODE>
<FONT COLOR="RED"># The module PDL::Bad contains a number of routines designed</FONT>
<FONT COLOR="RED"># to make using bad values easy.</FONT>
<STRONG>perldl></STRONG> print "a contains ", $a->nbad, " bad elements.\n";
<STRONG>perldl></STRONG> print "The bad value for type #",$a->get_datatype," is ",$a->badvalue,"\n";
<STRONG>perldl></STRONG> print "It is easy to find whether a value is good: ", isgood($a), "\n\n";
<STRONG>perldl></STRONG> print "or to remove the bad values\n";
<STRONG>perldl></STRONG> $a->inplace->setbadtoval(23);
<STRONG>perldl></STRONG> print "a = $a and \$a->badflag == ", $a->badflag, "\n\n";

a contains 1 bad elements.
The bad value for type #0 is 255
It is easy to find whether a value is good: [1 0 1]

or to remove the bad values
a = [1 23 3] and $a->badflag == 0

</CODE>
</PRE>

<!-- ----- -->

<PRE>
<CODE>
<STRONG>perldl></STRONG> print "We can even label certain values as bad!\n";
<STRONG>perldl></STRONG> $a = sequence(3,3);
<STRONG>perldl></STRONG> $a = $a->setbadif( $a % 2 );
<STRONG>perldl></STRONG> print $a;

We can even label certain values as bad!

[
 [  0 BAD   2]
 [BAD   4 BAD]
 [  6 BAD   8]
]
</CODE>
</PRE>

<!-- ----- -->

<PRE>
<CODE>
<FONT COLOR="RED"># the issue of how to cope with dataflow is not fully resolved. At</FONT>
<FONT COLOR="RED"># present, if you change the badflag of a piddle, all its children</FONT>
<FONT COLOR="RED"># are also changed:</FONT>
<STRONG>perldl></STRONG> $a = sequence( byte, 2, 3 );
<STRONG>perldl></STRONG> $a = $a->setbadif( $a == 3 );
<STRONG>perldl></STRONG> $b = $a->slice("(1),:");
<STRONG>perldl></STRONG> print "b = $b\tbadflag = ", $b->badflag, "\n";
<STRONG>perldl></STRONG> $a->inplace->setbadtoval(3);
<STRONG>perldl></STRONG> print "b = $b\tbadflag = ", $b->badflag, "\n\n";

b = [1 BAD 5]	badflag = 1
b = [1 3 5]	badflag = 0

</CODE>
</PRE>

<!-- ----- -->

<PRE>
<CODE>
<FONT COLOR="RED"># One area that is likely to cause confusion is the return value from</FONT>
<FONT COLOR="RED"># comparison operators (e.g. all and any) when ALL elements are bad.</FONT>
<FONT COLOR="RED"># Currently, the bad value is returned; however most code will not</FONT>
<FONT COLOR="RED"># be aware of this and just see it as a true or false value (depending</FONT>
<FONT COLOR="RED"># on the numerical value used to store bad values).</FONT>
<FONT COLOR="RED"># There is also the fact that the bad value need not relate to the</FONT>
<FONT COLOR="RED"># type of the input piddle (due to internal conversion to an 'int +').</FONT>
<STRONG>perldl></STRONG> $a = ones(3); $a = $a->setbadif( $a == 1 );
<STRONG>perldl></STRONG> print "Any returns: ", any( $a > 2 ), "\n";
<STRONG>perldl></STRONG> print "which is the bad value of 'long' (", long->badvalue, ").\n";
<STRONG>perldl></STRONG> print "Whereas the bad value for \$a is: ", $a->badvalue, "\n";

Any returns: -2147483648
which is the bad value of 'long' (-2147483648).
Whereas the bad value for $a is: -1.79769313486232e+308
</CODE>
</PRE>

<!-- ----- -->

<en-p>
Many of the 'core' routines have been converted to handle bad values.
However, some (including most of the additional modules) have not,
either because it does not make sense or its too much work to do! 
</en-p>

<de-p>
Der überwiegende Teil der 'core'-Routinen wurde bereits mit "bad value"-Support
versehen. Bei den meisten Zusatz-Modulen ist dies allerdings noch nicht der
Fall!
</de-p>

<!-- ----- -->

<en-p>
To find out the status of a particular routine, use the 'badinfo'
command in perldl (this information is also included when you do
'help'), or the '-b' switch of pdldoc.
</en-p>

<de-p>
Der Status einer Routine kann mit dem 'badinfo'-Kommando auf der perldl
Kommandozeile abgefragt werden und wird auf den 'help'-Seiten angezeigt. pdldoc
zeigt den Status bei Angabe der Option '-b' an. 
</de-p>

<!-- ---------------------------------------------------------------------- -->

#include "$(PDLROOT)/templates/footer_db.wml"
#include "$(PDLROOT)/templates/bottom.wml"

