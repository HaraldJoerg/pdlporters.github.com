#include "header.wml"
<lang:star:slice: plot2D_*.html>

<comment> ---------------------------------------------------------- </comment>
<HEAD*>
<META* HTTP-EQUIV = "KEYWORDS" 
       CONTENT    = "Schwebel"
>
<META* NAME       = "DESCRIPTION" 
       CONTENT    = "Robert Schwebel"
>
<TITLE*>PDL - Screenshots / Demos</TITLE*>
</HEAD*>
<comment> ---------------------------------------------------------- </comment>

<set-var doctype=html>

#include '$(PDLROOT)/templates/top.wml'
#include '$(PDLROOT)/menue.wml'

<!-- ---------------------------------------------------------------------- -->

<HR>

<EN><H2> 2D Plotting with PGPLOT </H2></EN>
<DE><H2> 2D Plots mit PGPLOT </H2></DE>
<ES><H2> 2D Diagramas con PGPLOT /H2></ES>

<en-p> Welcome to this tour of the PDL's PGPLOT interface.</en-p>

<de-p> Dies ist eine Einführung des PGPLOT-Interfaces von PDL. </de-p>

<!-- ----- -->

<en-p> This tour will introduce the PDL's PGPLOT plotting module and show what
this powerful package can provide in terms of plotting. It is not designed to
give a full tour of PGPLOT, you are advised to see the routines provided with
<CODE>pgperl</CODE> for that.</en-p>

<de-p> Diese kurze Tour wird einen Überblick über die vielfältigen
Möglichkeiten des PGPLOT-Moduls für PDL geben. Da der Überblick nicht
vollständig sein kann, sollte man sich die Beispiele, die bei
<CODE>pgperl</CODE> dabeisind, ebenfalls anschauen. </de-p>

<!-- ----- -->

<en-p>The PDL::Graphics::PGPLOT module provides a high-level interface
to PGPLOT. However if you want even better control of your plots
you might want to include the PGPLOT module specifically:</en-p>

<de-p>Das PDL::Graphics::PGPLOT-Modul stellt eine höher abstrahierte
Schnittstelle zu PGPLOT zur Verfügung. Möchte man eine detailliertere Kontrolle
über PGPLOT haben, sollte man das PGPLOT-Modul selbst einbinden:</de-p>

<!-- ----- -->

<PRE>
<CODE>
    use PGPLOT;
</CODE>
</PRE>

<!-- ----- -->

<en-p>One aspect of PGPLOT that requires mention is the use of devices:
Normally PGPLOT will inquire you about what device you want to use,
with the prompt:</en-p>

<de-p>Ein Aspekt von PGPLOT, der erwähnt werden soll, ist die Benutzung von
Devices: Im Normalfall fragt PGPLOT, welches Ausgabedevice Sie benutzen
möchten:</de-p>

<!-- ----- -->

<PRE>
<CODE>
    Graphics device/type (? to see list, default /NULL):
</CODE>
</PRE>

<P>
<HR><P>

<PRE>
<CODE>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># ensure the module is loaded (required for PDL versions >= 2.004)</FONT>
<STRONG>perldl></STRONG> use PDL::Graphics::PGPLOT;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># The size of the window can be specified</FONT>
<STRONG>perldl></STRONG> $ENV{PGPLOT_XW_WIDTH}=0.3;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># You can set your device explicitly</FONT>
<STRONG>perldl></STRONG> dev('/XSERVE');

<STRONG>perldl></STRONG> <FONT COLOR="RED"># First we define some variables to use for the rest of the demo.</FONT>
<STRONG>perldl></STRONG> $x=sequence(10);
<STRONG>perldl></STRONG> $y=2*$x**2;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># Now a simple plot with points</FONT>
<STRONG>perldl></STRONG> points $x, $y;

<A HREF="pgplot1.gif"><IMG ALT="[Thumbnail]" SRC="pg1.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED"># Here is the same with lines</FONT>
<STRONG>perldl></STRONG> line $x, $y;

<A HREF="pgplot2.gif"><IMG ALT="[Thumbnail]" SRC="pg2.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED"># If you want to overlay one plot you can use the command</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># 'hold' to put the graphics on hold and 'release' to</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># revert the effect</FONT>
<STRONG>perldl></STRONG> points $x, $y, {SYMBOL=>4};  <FONT COLOR="RED"># The last argument sets symboltype</FONT>
<STRONG>perldl></STRONG> hold;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># Now draw lines between the points</FONT>
<STRONG>perldl></STRONG> line $x, $y;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># Plot errorbars over the points</FONT>
<STRONG>perldl></STRONG> $yerr=sqrt($y);
<STRONG>perldl></STRONG> errb $x, $y, $yerr;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># To revert to old behaviour, use release</FONT>
<STRONG>perldl></STRONG> release;

<A HREF="pgplot3.gif"><IMG ALT="[Thumbnail]" SRC="pg3.gif"> Output</A>

<STRONG>perldl></STRONG> bin $x, $y;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># This plots a binned histogram of the data and as you can</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># see it made a new plot.</FONT>

<A HREF="pgplot4.gif"><IMG ALT="[Thumbnail]" SRC="pg4.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED"># 2D data can also easily be accomodated:</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># First make a simple image</FONT>
<STRONG>perldl></STRONG> $gradient=sequence(40,40);
<STRONG>perldl></STRONG> <FONT COLOR="RED"># Then display it.</FONT>
<STRONG>perldl></STRONG> imag $gradient;
<STRONG>perldl></STRONG> <FONT COLOR="RED"># And overlay a contour plot over it:</FONT>
<STRONG>perldl></STRONG> hold;
<STRONG>perldl></STRONG> cont $gradient;
<STRONG>perldl></STRONG> release;

<STRONG>perldl></STRONG> <FONT COLOR="RED"># PDL::Graphics::PGPLOT contains several colour tables,</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># a more extensive collection can be found in </FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># PDL::Graphics::LUT</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># (note: the call to lut_names() can take a few seconds to execute)</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> use PDL::Graphics::LUT;
<STRONG>perldl></STRONG> @names = lut_names();
<STRONG>perldl></STRONG> print "Available tables: [ ", @names, " ]\n";
<STRONG>perldl></STRONG> <FONT COLOR="RED"># use the first table</FONT>
<STRONG>perldl></STRONG> ctab( lut_data($names[0]) );
<STRONG>perldl></STRONG> use PGPLOT;
<STRONG>perldl></STRONG> pglabel "", "", "Colour table: $names[0]";

Available tables: [ aips0 backgr bgyrw blue blulut color green heat 
idl11 idl12 idl14 idl15 idl2 idl4 idl5 idl6 isophot light manycol pastel 
rainbow rainbow1 rainbow2 rainbow3 rainbow4 ramp random random1 random2 
random3 random4 random5 random6 real red smooth smooth1 smooth2 smooth3 
staircase stairs8 stairs9 standard ]

<A HREF="pgplot5.gif"><IMG ALT="[Thumbnail]" SRC="pg5.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED"># To change plot specifics you can either use the specific PGPLOT</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># commands - recommended if you need lots of control over your</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># plot.</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># Or you can use the new option specifications:</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># To plot our first graph again with blue color, dashed line</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># and a thickness of 10 we can do:</FONT>
<STRONG>perldl></STRONG> line $x, $y, {COLOR=>5, LINESTYLE=>'dashed', LINEWIDTH=>10};

<A HREF="pgplot6.gif"><IMG ALT="[Thumbnail]" SRC="pg6.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED"># Now for a more complicated example.</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># First create some data</FONT>
<STRONG>perldl></STRONG> $a=sequence(360)*3.1415/180.;
<STRONG>perldl></STRONG> $b=sin($a)*transpose(cos($a));
<STRONG>perldl></STRONG> <FONT COLOR="RED"># Make a piddle with the wanted contours</FONT>
<STRONG>perldl></STRONG> $contours=pdl [0.1,0.5,1.0];
<STRONG>perldl></STRONG> <FONT COLOR="RED"># And an array (reference to an array) with labels</FONT>
<STRONG>perldl></STRONG> $labels=['A', 'B', 'C'];
<STRONG>perldl></STRONG> <FONT COLOR="RED"># Create a contour map of the data - note that we can set the colour of</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># the labels.</FONT>
<STRONG>perldl></STRONG> cont($b, {CONTOURS=>$contours, linest=>'DASHED',
<STRONG>perldl></STRONG> LINEWIDTH=>3, COLOR=>2, LABELCOL=>4});
<STRONG>perldl></STRONG> hold;
<STRONG>perldl></STRONG> pgqlw($linewidth);
<STRONG>perldl></STRONG> points $a->slice('0:-1:4')*180./3.1415;
<STRONG>perldl></STRONG> release;

<A HREF="pgplot7.gif"><IMG ALT="[Thumbnail]" SRC="pg7.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># More examples of changing the plot defaults</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># </FONT>
<STRONG>perldl></STRONG> $a = 1+sequence(10);
<STRONG>perldl></STRONG> $b = $a*2;
<STRONG>perldl></STRONG> $bord_opt = { TYPE => 'RELATIVE', VALUE => 0.1 };
<STRONG>perldl></STRONG> line log10($a), $b, { AXIS => 'LOGX', BORDER => $bord_opt };

<A HREF="pgplot8.gif"><IMG ALT="[Thumbnail]" SRC="pg8.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># We can also create vector maps of data</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># This requires one array for the horizontal component and</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># one for the vertical component</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> $horizontal=sequence(10,10);
<STRONG>perldl></STRONG> $vertical=transpose($horizontal)+random(10,10)*$horizontal/10.;
<STRONG>perldl></STRONG> $arrow={ARROW=> {FS=>1, ANGLE=>25, VENT=>0.7, SIZE=>3}};
<STRONG>perldl></STRONG> vect $horizontal, $vertical, {ARROW=>$arrow, COLOR=>RED};
<STRONG>perldl></STRONG> hold;
<STRONG>perldl></STRONG> cont $vertical-$horizontal, {COLOR=>YELLOW};
<STRONG>perldl></STRONG> release;

<A HREF="pgplot9.gif"><IMG ALT="[Thumbnail]" SRC="pg9.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># To draw [filled] polygons, the command poly is handy:</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> $x=sequence(10)/5;
<STRONG>perldl></STRONG> poly $x, $x**2, {FILL=>HATCHED, COLOR=>BLUE};

<A HREF="pgplot10.gif"><IMG ALT="[Thumbnail]" SRC="pg10.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># the latest feature of PDL are complex numbers</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># so let's play with a simple example</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> use PDL::Complex;
<STRONG>perldl></STRONG> $z50 = zeroes(50);
<STRONG>perldl></STRONG> $c = $z50->xlinvals(0,7)+i*$z50->xlinvals(2,4);
<STRONG>perldl></STRONG> line im sin $c; hold;      <FONT COLOR="RED"># the imaginary part</FONT>
<STRONG>perldl></STRONG> line re sin $c;            <FONT COLOR="RED"># real</FONT>
<STRONG>perldl></STRONG> line abs sin $c; release;  <FONT COLOR="RED"># and the modulus</FONT>
  
<A HREF="pgplot11.gif"><IMG ALT="[Thumbnail]" SRC="pg11.gif"> Output</A>

<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED"># more complex numbers</FONT>
<STRONG>perldl></STRONG> <FONT COLOR="RED">#</FONT>
<STRONG>perldl></STRONG> use PDL::Complex;
<STRONG>perldl></STRONG> $c =  zeroes(300)->xlinvals(0,12)+i*zeroes(300)->xlinvals(2,10);
<STRONG>perldl></STRONG> $sin = sin $c;
<STRONG>perldl></STRONG> line $sin->im, $sin->re;   <FONT COLOR="RED"># look at the result in the complex plane</FONT>
  
<A HREF="pgplot12.gif"><IMG ALT="[Thumbnail]" SRC="pg12.gif"> Output</A>

</PRE>

#include "$(PDLROOT)/templates/footer_rs.wml"
#include "$(PDLROOT)/templates/bottom.wml"
