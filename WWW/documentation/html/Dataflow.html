    <HTML> 
	<HEAD> 
	    <TITLE>PDL::Dataflow -- description of the dataflow philosophy

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#WARNING">WARNING</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#Lazy_evaluation">Lazy evaluation</A>
	<LI><A HREF="#Families">Families</A>
	<LI><A HREF="#Sources">Sources</A>
	<LI><A HREF="#Binding">Binding</A>
	<LI><A HREF="#Limitations">Limitations</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME

</A></H1>
PDL::Dataflow -- description of the dataflow philosophy


<P>

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS

</A></H1>
<PRE>        perldl&gt; $a = zeroes(10);
        perldl&gt; $b = $a-&gt;slice(&quot;2:4:2&quot;);
        perldl&gt; $b ++;
        perldl&gt; print $a;
        [0 0 1 0 1 0 0 0 0 0]
</PRE>

<P>

<P>
<HR>
<H1><A NAME="WARNING">WARNING

</A></H1>
Dataflow is very experimental. Many features of it are disabled for 2.0,
particularly families for one-directional dataflow. If you wish to use
one-directional dataflow for something, please contact the author first and
we'll work out how to make it functional again.


<P>

Two-directional dataflow (which implements -&gt;slice() etc.) is fully
functional, however. Just about any function which returns some subset of
the values in some piddle will make a binding so that


<P>

<PRE>        $a = some piddle
        $b = $a-&gt;slice(&quot;some parts&quot;);
        $b-&gt;set(3,3,10);
</PRE>

<P>

also changes the corresponding element in $a. <CODE>$b</CODE> has become
effectively a window to some subelements of $a. You can also define your
own routines that do different types of subsets. If you don't want
<CODE>$b</CODE> to be a window to $a, you must do


<P>

<PRE>        $b = $a-&gt;slice(&quot;some parts&quot;)-&gt;copy;
</PRE>

<P>

The copying turns off all dataflow between the two piddles.


<P>

The difficulties with one-directional dataflow are related to sequences
like


<P>

<PRE>        $b = $a + 1;
        $b ++;
</PRE>

<P>

where there are several possible outcomes and the semantics get a little
murky.


<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
Dataflow is new to PDL2.0. The basic philosophy behind dataflow is that


<P>

<PRE>        &gt; $a = pdl 2,3,4;
        &gt; $b = $a * 2;
        &gt; print $b
        [2 3 4]
        &gt; $a-&gt;set(0,5);
        &gt; print $b;
        [10 3 4]
</PRE>

<P>

should work. It doesn't. It was considered that doing this might be too
confusing for novices and occasional users of the language. Therefore, you
need to explicitly turn on dataflow, so


<P>

<PRE>        &gt; $a = pdl 2,3,4;
        &gt; $a-&gt;doflow();
        &gt; $b = $a * 2;
        ...
</PRE>

<P>

produces the (un)expected result. The rest of this documents explains
various features and details of the dataflow implementation.


<P>

<P>
<HR>
<H1><A NAME="Lazy_evaluation">Lazy evaluation

</A></H1>
When you calculate something like the above


<P>

<PRE>        &gt; $a = pdl 2,3,4;
        &gt; $a-&gt;doflow();
        &gt; $b = $a * 2;
</PRE>

<P>

nothing will have been calculated at this point. Even the memory for the
contents of <CODE>$b</CODE> has not been allocated. Only the command


<P>

<PRE>        &gt; print $b
</PRE>

<P>

will actually cause <CODE>$b</CODE> to be calculated. This is important to
bear in mind when doing performance measurements and benchmarks as well as
when tracking errors.


<P>

There is an explanation for this behaviour: it may save cycles but more
importantly, imagine the following:


<P>

<PRE>        &gt; $a = pdl 2,3,4;
        &gt; $b = pdl 5,6,7;
        &gt; $c = $a + $b;
        ...
        &gt; $a-&gt;resize(4);
        &gt; $b-&gt;resize(4);
        &gt; print $c;
</PRE>

<P>

Now, if <CODE>$c</CODE> were evaluated between the two resizes, an error
condition of incompatible sizes would occur.


<P>

What happens in the current version is that resizing <CODE>$a</CODE> raises
a flag in $c: ``PDL_PARENTDIMSCHANGED'' and <CODE>$b</CODE> just raises the
same flag again. When <CODE>$c</CODE> is next evaluated, the flags are
checked and it is found that a recalculation is needed.


<P>

Of course, lazy evaluation can sometimes make debugging more painful
because errors may occur somewhere where you'd not expect them. A better
stack trace for errors is in the works for PDL, probably so that you can
toggle a switch $PDL::traceevals and get a good trace of where the error
actually was.


<P>

<P>
<HR>
<H1><A NAME="Families">Families

</A></H1>
This is one of the more intricate concepts of one-directional dataflow.
Consider the following code ($a and <CODE>$b</CODE> are pdls that have
dataflow enabled):


<P>

<PRE>        $c = $a + $b;
        $e = $c + 1;
        $d = $c-&gt;diagonal();
        $d ++;
        $f = $c + 1;
</PRE>

<P>

What should <CODE>$e</CODE> and <CODE>$f</CODE> contain now? What about
when <CODE>$a</CODE> is changed and a recalculation is triggered.


<P>

In order to make dataflow work like you'd expect, a rather strange concept
must be introduced: families. Let us make a diagram:


<P>

<PRE>        a   b
         \ /
          c
         /|
        / |
       e  d
</PRE>

<P>

This is what PDL actually has in memory after the first three lines. When
<CODE>$d</CODE> is changed, we want <CODE>$c</CODE> to change but we don't
want <CODE>$e</CODE> to change because it already is on the graph. It may
not be clear now why you don't want it to change but if there were 40 lines
of code between the 2nd and 4th lines, you would. So we need to make a copy
of <CODE>$c</CODE> and $d:


<P>

<PRE>        a   b
         \ /
          c' . . . c
         /|        |\
        / |        | \
       e  d' . . . d  f
</PRE>

<P>

Notice that we primed the original c and d, because they do not correspond
to the objects in <CODE>$c</CODE> and <CODE>$d</CODE> any more. Also,
notice the dotted lines between the two objects: when <CODE>$a</CODE> is
changed and this diagram is re-evaluated, <CODE>$c</CODE> really does get
the value of c' with the diagonal incremented.


<P>

To generalize on the above, whenever a piddle is mutated i.e. when its
actual *value* is forcibly changed (not just the reference:


<P>

<PRE>        $d = $d + 1
</PRE>

<P>

would produce a completely different result ($c and <CODE>$d</CODE> would
not be bound any more whereas <CODE>$d</CODE> .= <CODE>$d</CODE> + 1


<P>

would yield the same as $d++), a ``family'' consisting of all other piddles
joined to the mutated piddle by a two-way transformation is created and all
those are copied.


<P>

All slices or transformations that simply select a subset of the original
pdl are two-way. Matrix inverse should be. No arithmetic operators are.


<P>

<P>
<HR>
<H1><A NAME="Sources">Sources

</A></H1>
What you were told in the previous section is not quite true: the behaviour
described is not *always* what you want. Sometimes you would probably like
to have a data ``source'':


<P>

<PRE>        $a = pdl 2,3,4; $b = pdl 5,6,7;
        $c = $a + $b;
        line($c);
</PRE>

<P>

Now, if you know that <CODE>$a</CODE> is going to change and that you want
its children to change with it, you can declare it into a data source (XXX
unimplemented in current version):


<P>

<PRE>        $a-&gt;datasource(1);
</PRE>

<P>

After this, $a++ or <CODE>$a</CODE> .= something will not create a new
family but will alter <CODE>$a</CODE> and cut its relation with its
previous parents. All its children will follow its current value.


<P>

So if <CODE>$c</CODE> in the previous section had been declared as a
source, <CODE>$e</CODE> and <CODE>$f</CODE> would remain equal.


<P>

<P>
<HR>
<H1><A NAME="Binding">Binding

</A></H1>
A dataflow mechanism would not be very useful without the ability to bind
events onto changed data. Therefore, we provide such a mechanism:


<P>

<PRE>        &gt; $a = pdl 2,3,4
        &gt; $b = $a + 1;
        &gt; $c = $b * 2;
        &gt; $c-&gt;bind( sub { print &quot;A now: $a, C now: $c\n&quot; } )
        &gt; PDL::dowhenidle();
        A now: [2,3,4], C now: [6 8 10]
        &gt; $a-&gt;set(0,1);
        &gt; $a-&gt;set(1,1);
        &gt; PDL::dowhenidle();
        A now: [1,1,4], C now: [4 4 10]
</PRE>

<P>

Notice how the callbacks only get called during PDL::dowhenidle. An easy
way to interface this to Perl event loop mechanisms (such as Tk) is being
planned.


<P>

There are many kinds of uses for this feature: self-updating graphs, for
instance.


<P>

Bla bla bla XXX more explanation


<P>

<P>
<HR>
<H1><A NAME="Limitations">Limitations

</A></H1>
Dataflow as such is a fairly limited addition on top of Perl. To get a more
refined addition, the internals of perl need to be hacked a little. A true
implementation would enable flow of everything, including


<P>

<DL>
<DT><STRONG><A NAME="item_data">data

</A></STRONG><DD>
<DT><STRONG>data size

</A></STRONG><DD>
<DT><STRONG><A NAME="item_datatype">datatype

</A></STRONG><DD>
<DT><STRONG><A NAME="item_operations">operations

</A></STRONG><DD>
</DL>
At the moment we only have the first two (hey, 50% in a couple of months is
not bad ;) but even this is useful by itself. However, especially the last
one is desirable since it would add the possibility of flowing closures
from place to place and would make many things more flexible.


<P>

To get the rest working, the internals of dataflow probably need to be
changed to be a more general framework.


<P>

Additionally, it would be nice to be able to flow data in time, lucid-like
(so you could easily define all kinds of signal processing things).


<P>

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>
<CODE>Copyright(C)</CODE> 1997 Tuomas J. Lukka <A
HREF="MAILTO:(lukka@fas.harvard.edu).">(lukka@fas.harvard.edu).</A>
Redistribution in the same form is allowed provided that the copyright
notice stays intact but reprinting requires a permission from the author.

<P>

</DL>
    </BODY>

    </HTML>
