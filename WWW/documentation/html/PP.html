    <HTML> 
	<HEAD> 
	    <TITLE>PDL::PP - Generate PDL routines from concise descriptions

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#Overview">Overview</A>
	<LI><A HREF="#WARNING">WARNING</A>
	<LI><A HREF="#ABANDON_ALL_HOPE_YE_WHO_ENTER_H">ABANDON ALL HOPE, YE WHO ENTER HERE (DESCRIPTION)</A>
	<LI><A HREF="#Data_operation">Data operation</A>
	<UL>

		<LI><A HREF="#A_simple_example">A simple example</A>
		<LI><A HREF="#The_C_Pars_section_the_signat">The <CODE>Pars</CODE> section : the signature of a PP function</A>
		<LI><A HREF="#Argument_dimensions_and_the_sign">Argument dimensions and the signature</A>
		<LI><A HREF="#Type_conversions_and_the_signatu">Type conversions and the signature</A>
		<LI><A HREF="#The_C_Code_section">The <CODE>Code</CODE> section</A>
		<LI><A HREF="#Interfacing_your_own_library_fun">Interfacing your own/library functions using PP</A>
		<LI><A HREF="#Other_macros_and_functions_in_th">Other macros and functions in the Code section</A>
		<LI><A HREF="#Other_useful_PP_keys_in_data_ope">Other useful PP keys in data operation definitions</A>
		<LI><A HREF="#Other_PDL_PP_functions_to_suppo">Other PDL::PP functions to support concise package definition</A>
	</UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#use_myfunc">use_myfunc</A>
		<LI><A HREF="#Slice_operation">Slice operation</A>
		<LI><A HREF="#Makefiles_for_PP_files">Makefiles for PP files</A>
		<LI><A HREF="#INTERNALS">INTERNALS</A>
	</UL>

	<LI><A HREF="#Appendix_A_Some_keys_recognised">Appendix A: Some keys recognised by PDL::PP</A>
	<LI><A HREF="#Appendix_B_PP_macros_and_functi">Appendix B: PP macros and functions</A>
	<UL>

		<LI><A HREF="#Macros">Macros</A>
		<LI><A HREF="#functions">functions</A>
	</UL>

	<LI><A HREF="#CURRENTLY_UNDOCUMENTED">CURRENTLY UNDOCUMENTED</A>
	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME

</A></H1>
PDL::PP - Generate PDL routines from concise descriptions


<P>

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS

</A></H1>
e.g.


<P>

<PRE>        pp_def(
                'sumover',
                Pars =&gt; 'a(n); [o]b();',
                Code =&gt; 'double tmp=0;
                        loop(n) %{ tmp += $a(); %}
                        $b() = tmp;
                        '
        );
</PRE>

<P>

<PRE>        pp_done();
</PRE>

<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
In much of what follows we will assume familiarity of the reader with the
concepts of implicit and explicit threading and index manipulations within
PDL. If you have not yet heard of these concepts or are not very
comfortable with them it is time to check <EM>PDL/Indexing</EM>.


<P>

As you may appreciate from its name PDL::PP is a Pre-Processor, i.e. it
expands code via substitutions to make real C-code (well, actually it
outputs XS code (See <EM>perlxs</EM>) but that is very close to C).


<P>

<P>
<HR>
<H1><A NAME="Overview">Overview

</A></H1>
Why do we need PP? Several reasons: firstly, we want to be able to generate
subroutine code for each of the PDL datatypes (PDL_Byte, PDL_Short,. etc).
AUTOMATICALLY. Secondly, when referring to slices of PDL arrays in Perl
(e.g. <CODE>$a-&gt;slice('0:10:2,:')</CODE> or other things such as transposes) it is nice to be able to do this
transparently and to be able to do this 'in-place' - i.e, not to have to
make a memory copy of the section. PP handles all the necessary element and
offset arithmetic for you. There are also the notions of threading
(repeated calling of the same routine for multiple slices, see <EM>PDL/Indexing</EM>) and dataflow (see <EM>PDL/Dataflow</EM>) which use of PP allows. 


<P>

So how do you use PP? Well for the most part you just write ordinary C code
except for special PP constructs which take the form:


<P>

<PRE>    $something(something else)
</PRE>

<P>

or:


<P>

<PRE>   PPfunction %{ 
     &lt;stuff&gt; 
   %}
</PRE>

<P>

The most important PP construct is the form <CODE>$array()</CODE>. Consider the very simple PP function to sum the elements of a 1D vector
(in fact this is very similar to the actual code used by 'sumover'):


<P>

<PRE>   pp_def('sumit',
           Pars =&gt; 'a(n);  [o]b();',
           Code =&gt; '
                double tmp;
                tmp = 0;
                loop(n) %{ 
                  tmp += $a(); 
                %}
                $b() = tmp;
   ');
</PRE>

<P>

What's going on? The <CODE>Pars =&gt;</CODE> line is very important for PP - it specifies all the arguments and their
dimensionality. We call this the <EM>signature</EM> of the PP function (compare also the explanations in
<EM>PDL/Indexing</EM>). In this case the routine takes a 1-D function as input and returns a 0-D
scalar as output. The <CODE>$a()</CODE> PP construct is used to access elements of the array <CODE>a(n)</CODE> for
you - PP fills in all the required C code.


<P>

[Aside: since PP used <CODE>$var()</CODE> for its parsing you must single-quote all Code=&gt; arguments since you
don't want perl to interpolate <CODE>$var()</CODE> into another string - i.e. don't use ``'' unless you know what you are
doing! Tjl: it's usually easiest to use single quotes and
'something'.$interpolatable.'somethingelse']


<P>

In the simple case here where all elements are accessed the PP construct
<A HREF="#item_loop_">loop(n) %{ ... %}</A> is used to loop over all elements in dimension <CODE>n</CODE>. Note this feature of PP: ALL DIMENSIONS ARE SPECIFIED BY NAME.


<P>

This is made clearer if we avoid the PP <CODE>loop()</CODE> construct and
write the loop explicitly using conventional C:


<P>

<PRE>   pp_def('sumit',
           Pars =&gt; 'a(n);  [o]b();',
           Code =&gt; '
                int i,n_size;
                double tmp;
                n_size = $SIZE(n); 
                tmp = 0;
                for(i=0; i&lt;n_size; i++) {
                  tmp += $a(n=&gt;i); 
                }
                $b() = tmp;
   ');
</PRE>

<P>

which does the same as before, except more long-windedly. You can see to
get element <CODE>i</CODE> of <CODE>a()</CODE> we say <CODE>$a(n=&gt;i)</CODE> - we are specifying the dimension by name <CODE>n</CODE>. In 2D we might say:


<P>

<PRE>   Pars=&gt;'a(m,n);',
      ...
      tmp += $a(m=&gt;i,n=&gt;j);
      ...
</PRE>

<P>

The syntax 'm=&gt;i' borrows from Perl hashes (which are in fact used in the implementation
of PP). One could also say
<CODE>$a(n=&gt;j,m=&gt;i)</CODE> as order is not important.


<P>

You can also see in the above example the use of another PP construct - <CODE>$SIZE(n)</CODE> to get the length of the dimension
<CODE>n</CODE>.


<P>

It should, however, be noted that you shouldn't write an explicit C-loop
when you could have used the PP <A HREF="#item_loop">loop</A> construct since PDL::PP checks automatically the loop limits for you, usage
of <A HREF="#item_loop">loop</A> makes the code more concise, etc. But there are certainly situations where
you need explicit control of the loop and now you know how to do it ;).


<P>

To revisit 'Why PP?' - the above code for <CODE>sumit()</CODE> will be
generated for each data-type. It will operate on slices of arrays
'in-place'. It will thread automatically - e.g. if a 2D array is given it
will be called repeatedly for each 1D row (again check <EM>PDL/Indexing</EM> for the details of threading). And then <CODE>b()</CODE> will be a 1D array
of sums of each row. We could call it with $a-&gt;xchg(0,1) to sum the
colums instead. And Dataflow tracing etc. will be available.


<P>

You can see PP saves the programmer from writing a lot of needlessly
repetitive C-code -- in our opinion this is one of the best features of PDL
making writing new C subroutines for PDL an amazingly concise exercise. A
second reason is the ability to make PP expand your concise code
definitions into different C code based on the needs of the computer
architecture in question. Imagine for example you are lucky to have a
supercomputer at your hands; in that case you want PDL::PP certainly to
generate code that takes advantage of the vectorising/parallel computing
features of your machine (this a project for the future). In any case, the
bottom line is that your unchanged code should still expand to working XS
code even if the internals of PDL changed.


<P>

Also, because you are generating the code in an actual Perl script, there
are many fun things that you can do. Let's say that you need to write both
sumit (as above) and multit. With a little bit of inventivity, we can do


<P>

<PRE>   for({Name =&gt; 'sumit', Init =&gt; '0', Op =&gt; '+='},
       {Name =&gt; 'multit', Init =&gt; '1', Op =&gt; '*='}) {
           pp_def($_-&gt;{Name},
                   Pars =&gt; 'a(n);  [o]b();',
                   Code =&gt; '
                        double tmp;
                        tmp = '.$_-&gt;{Init}.';
                        loop(n) %{ 
                          tmp '.$_-&gt;{Op}.' $a(); 
                        %}
                        $b() = tmp;
           ');
   }
</PRE>

<P>

which defines both the functions easily. Now, if you later need to change
the signature or dimensionality or whatever, you only need to change one
place in your code. Yeah, sure, your editor does have 'cut and paste' and
'search and replace' but it's still less bothersome and definitely more
difficult to forget just one place and have strange bugs creep in. Also,
adding 'orit' (bitwise or) later is a one-liner. 


<P>

And remember, you really have perl's full abilities with you - you can very
easily read any input file and make routines from the information in that
file. For simple cases like the above, the author (Tjl) currently favors
the hash syntax like the above - it's not too much more characters than the
corresponding array syntax but much easier to understand and change.


<P>

We should mention here also the ability to get the pointer to the beginning
of the data in memory - a prerequisite for interfacing PDL to some
libraries. This is handled with the <CODE>$P(var)</CODE> directive, see below.


<P>

So, after this quick overview of the general flavour of programming PDL
routines using PDL::PP let's summarise in which circumstances you should
actually use this preprocessor/precompiler. You should use PDL::PP if you
want to


<P>

<DL>
<DT><STRONG></STRONG><DD>
interface PDL to some external library


<P>

<DT><STRONG></STRONG><DD>
write some algorithm that would be slow if coded in perl (this is not as
often as you think; take a look at threading and dataflow first).


<P>

<DT><STRONG></STRONG><DD>
be a PDL developer (and even then it's not obligatory)


<P>

</DL>
<P>
<HR>
<H1><A NAME="WARNING">WARNING

</A></H1>
Because of its architecture, PDL::PP can be both flexible and easy to use
(yet exuberantly complicated) at the same time. Currently, part of the
problem is that error messages are not very informative and if something
goes wrong, you'd better know what you are doing and be able to hack your
way through the internals (or be able to figure out by trial and error what
is wrong with your args to <CODE>pp_def</CODE>).


<P>

An alternative, of course, is to ask someone about it (e.g., through the
mailing lists).


<P>

<P>
<HR>
<H1><A NAME="ABANDON_ALL_HOPE_YE_WHO_ENTER_H">ABANDON ALL HOPE, YE WHO ENTER HERE (DESCRIPTION)

</A></H1>
Now that you have some idea how to use <CODE>pp_def</CODE> to define new PDL functions it is time to explain the general syntax of <CODE>pp_def</CODE>. 
<CODE>pp_def</CODE> takes as arguments first the name of the function you are defining and then
a hash list that can contain various keys.


<P>

Based on these keys PP generates XS code and a .pm file. The function
<CODE>pp_done</CODE> (see example in the SYNOPSIS) is used to tell PDL::PP that there are no
more definitions in this file and it is time to generate the .xs and .pm
file.


<P>

As a consequence, there may be several <CODE>pp_def()</CODE> calls inside a
file (by convention files with PP code have the extension .pd or .pp) but
generally only one <CODE>pp_done().</CODE>


<P>

There are two main different types of usage of <CODE>pp_def(),</CODE> the
'data operation' and 'slice operation' prototypes.


<P>

The 'data operation' is used to take some data, mangle it and output some
other data; this includes for example the '+' operation, matrix inverse,
sumover etc and all the examples we have talked about in this document so
far. Implicit and explicit threading and the creation of the result are
taken care of automatically in those opeartions. You can even do dataflow
with <CODE>sumit</CODE>, <CODE>sumover</CODE>, etc (don't be dismayed if you don't understand the concept of dataflow in
PDL very well yet; it is still very much experimental).


<P>

The 'slice operation' is a different kind of operation: in a slice
operation, you are not changing any data, you are defining correspondences
between different elements of two piddles (examples include the index
manipulation/slicing function definitions in the file <EM>slices.pd</EM> 
that is part of the PDL distribution; but beware, this is not introductory
level stuff).


<P>

If you are just interested in communicating with some external library (for
example some linear algebra/matrix library), you'll usually want the 'data
operation' so we are going to discuss that first.


<P>

<P>
<HR>
<H1><A NAME="Data_operation">Data operation

</A></H1>
<P>
<HR>
<H2><A NAME="A_simple_example">A simple example

</A></H2>
In the data operation, you must know what dimensions of data you need.
First, an example with scalars:


<P>

<PRE>        pp_def('add',
                Pars =&gt; 'a(); b(); [o]c();',
                Code =&gt; '$c() = $a() + $b();'
        );
</PRE>

<P>

That looks a little strange but let's dissect it. The first line is easy:
we're defining a routine with the name 'add'. The second line simply
declares our parameters and the parentheses mean that they are scalars. We
call the string that defines our parameters and their dimensionality the <EM>signature</EM> of that function. For its relevance with regard to threading and index
manipulations check the 
<EM>PDL/Indexing</EM> manpage.


<P>

The third line is the actual operation. You need to use the dollar signs
and parentheses to refer to your parameters (this will probably change at
some point in the future, once a good syntax is found).


<P>

These lines are all that is necessary to actually define the function for
PDL (well, actually it isn't; you aditionally need to write a Makefile.PL
(see below) and build the module (something like 'perl Makefile.PL; make');
but let's ignore that for the moment). So now you can do


<P>

<PRE>        use MyModule;
        $a = pdl 2,3,4;
        $b = pdl 5;
</PRE>

<P>

<PRE>        $c = add($a,$b);
        # or
        add($a,$b,($c=null)); # Alternative form, useful if $c has been
                              # preset to something big, not useful here.
</PRE>

<P>

and have threading work correctly (the result is <CODE>$c</CODE> == [7 8
9]).


<P>

<P>
<HR>
<H2><A NAME="The_C_Pars_section_the_signat">The <A HREF="#item_Pars">Pars</A> section : the signature of a PP function

</A></H2>
Seeing the above example code you will most probably ask: what is this
strange <CODE>$c=null</CODE> syntax in the second call to our new <CODE>add</CODE> function? If you take another look at the definition of <CODE>add</CODE> you will notice that the third argument <CODE>c</CODE> is flagged with the qualifier <CODE>[o]</CODE> which tells PDL::PP that this is an output argument. So the above call to
add means 'create a new <CODE>$c</CODE> from scratch with correct
dimensions' -
<CODE>null</CODE> is a special token for 'empty piddle' (you might ask why we haven't used
the value <CODE>undef</CODE> to flag this instead of the PDL specific <CODE>null</CODE>; we are currently thinking about it ;).


<P>

[This should be explained in some other section of the manual as well!!]
The reason for having this syntax as an alternative is that if you have
really huge piddles, you can do 


<P>

<PRE>        $c = PDL-&gt;null;
        for(some long loop) {
                # munge a,b
                add($a,$b,$c);
                # munge c, put something back to a,b
        }
</PRE>

<P>

and avoid allocating and deallocating <CODE>$c</CODE> each time. It is
allocated once at the first <CODE>add()</CODE> and thereafter the memory
stays until <CODE>$c</CODE> is destroyed.


<P>

If you just say


<P>

<PRE>  $c =  add($a,$b);
</PRE>

<P>

the code generated by PP will automatically fill in <CODE>$c=null</CODE> 
and return the result. If you want to learn more about the reasons why
PDL::PP supports this style where output arguments are given as last
arguments check the 
<EM>PDL/Indexing</EM> manpage.


<P>

<CODE>[o]</CODE> is not the only qualifier a pdl argument can have in the signature. Another
important qualifier is the <CODE>[t]</CODE> option which flags a pdl as temporary. What does that mean? You tell
PDL::PP that this pdl is only used for temporary results in the course of
the calculation and you are not interested in its value after the
computation has been completed. But why should PDL::PP want to know about
this in the first place? The reason is closely related to the concepts of
pdl auto creation (you heard about that above) and implicit threading. If
you use implicit threading the dimensionality of automatically created pdls
is actually larger than that specified in the signature. With <CODE>[o]</CODE> flagged pdls will be created so that they have the additional dimensions as
required by the number of implicit thread dimensions. When creating a
temporary pdl, however, it will always only be made big enough so that it
can hold the result for one iteration in a threadloop, i.e. as large as
required by the signature. So less memory is wasted when you flag a pdl as
temporary. Secondly, you can use output auto creation with temporary pdls
even when you are using explicit threading which is forbidden for normal
output pdls flagged with
<CODE>[o]</CODE> (see <EM>PDL/Indexing</EM>).


<P>

Here is an example where we use the [t] qualifier. We define the function
<CODE>callf</CODE> that calls a C routine <CODE>f</CODE> which needs a temporary array of the same size and type as the array <CODE>a</CODE> (sorry about the forward reference for <CODE>$P</CODE>; it's a pointer access, see below) :


<P>

<PRE>  pp_def('callf',
        Pars =&gt; 'a(n); [t] tmp(n); [o] b()',
        Code =&gt; 'int ns = $SIZE(n);
                 f($P(a),$P(b),$P(tmp),ns);
                '
  );
</PRE>

<P>

<P>
<HR>
<H2><A NAME="Argument_dimensions_and_the_sign">Argument dimensions and the signature

</A></H2>
Now we have just talked about dimensions of pdls and the signature. How are
they related? Let's say that we want to add a scalar + the index number to
a vector:


<P>

<PRE>        pp_def('add2',
                Pars =&gt; 'a(n); b(); [o]c(n);',
                Code =&gt; 'loop(n) %{
                                $c() = $a() + $b() + n;
                         %}'
        );
</PRE>

<P>

There are several points to notice here: first, the <A HREF="#item_Pars">Pars</A>
argument now contains the <EM>n</EM> arguments to show that we have a single dimensions in <EM>a</EM> and <EM>c</EM>. It is important to note that dimensions are actual entities that are
accessed by name so this declares
<EM>a</EM> and <EM>c</EM> to have the <STRONG>same</STRONG> first dimensions. In most PP definitions the size of named dimensions will
be set from the respective dimensions of non-output pdls (those with no <CODE>[o]</CODE> flag) but sometimes you might want to set the size of a named dimension
explicitly through an integer parameter. See below in the description of
the <A HREF="#item_OtherPars">OtherPars</A> section how that works.


<P>

<P>
<HR>
<H2><A NAME="Type_conversions_and_the_signatu">Type conversions and the signature

</A></H2>
The signature also determines the type conversions that will be performed
when a PP function is invoked. So what happens when we invoke one of our
previously defined functions with pdls of different type, e.g.


<P>

<PRE>  add2($a,$b,($ret=null));
</PRE>

<P>

where <CODE>$a</CODE> is of type <CODE>PDL_Float</CODE> and <CODE>$b</CODE> of type <CODE>PDL_Short</CODE>? With the signature as shown in the definition of <CODE>add2</CODE> above the datatype of the operation (as determined at runtime) is that of
the pdl with the 'highest' type (sequence is byte &lt; short &lt; ushort
&lt; long &lt; float &lt; double). In the add2 example the datatype of the
operation is float ($a has that datatype). All pdl arguments are then type
converted to that datatype (they are not converted inplace but a copy with
the right type is created if a pdl argument doesn't have the type of the
operation). Null pdls don't contribute a type in the determination of the
type of the operation. However, they will be created with the datatype of
the operation; here, for example, <CODE>$ret</CODE> will be of type float.
You should be aware of these rules when calling PP functions with pdls of
different types to take the additional storage and runtime requirements
into account.


<P>

These type conversions are correct for most functions you normally define
with <CODE>pp_def</CODE>. However, there are certain cases where slightly modified type conversion
behaviour is desired. For these cases additional qualifiers in the
signature can be used to specify the desired properties with regard to type
conversion. These qualifiers can be combined with those we have encountered
already (the <EM>creation qualifiers</EM>  <CODE>[o]</CODE> and <CODE>[t]</CODE>). Let's go through the list of qualifiers that change type conversion
behaviour.


<P>

The most important is the <CODE>int</CODE> qualifier which comes in handy when a pdl argument represents indices into
another pdl. Let's take a look at an example from <CODE>PDL::Primitive</CODE>:


<P>

<PRE>   pp_def('maximum_ind',
          Pars =&gt; 'a(n); int [o] b()',
          Code =&gt; '$GENERIC() cur;
                   int curind;
                   loop(n) %{
                    if (!n || $a() &gt; cur) {cur = $a(); curind = n;}
                   %}
                   $b() = curind;',
   );
</PRE>

<P>

The function <CODE>maximum_ind</CODE> finds the index of the largest element of a vector. If you look at the
signature you notice that the output argument <CODE>b</CODE> has been declared with the additional <CODE>int</CODE> qualifier. This has the following consequences for type conversions:
regardless of the type of the input pdl <CODE>a</CODE> the output pdl <CODE>b</CODE> will be of type 
<CODE>PDL_Long</CODE> which makes sense since <CODE>b</CODE> will represent an index into
<CODE>a</CODE>. Furthermore, if you call the function with an existing output pdl <CODE>b</CODE> its type will not influence the datatype of the operation (see above).
Hence, even if <CODE>a</CODE> is of a smaller type than <CODE>b</CODE> it will not be converted to match the type of <CODE>b</CODE> but stays untouched, which saves memory and CPU cycles and is the right
thing to do when <CODE>b</CODE> represents indices. Also note that you can use the 'int' qualifier together
with other qualifiers (the <CODE>[o]</CODE> and <CODE>[t]</CODE> qualifiers). Order is significant -- type qualifiers precede creation
qualifiers (<CODE>[o]</CODE> and <CODE>[t]</CODE>).


<P>

The above example also demonstrates typical usage of the <CODE>$GENERIC()</CODE>
macro. It expands to the current type in a so called generic loop. What is
a generic loop? As you already heard a PP function has a runtime datatype
as determined by the type of the pdl arguments it has been invoked with.
The PP generated XS code for this function therefore contains a switch like <CODE>switch (type) {case PDL_Byte: ... case
PDL_Double: ...}</CODE> that selects a case based on the runtime datatype of the function (it's
called a type ``loop'' because there is a loop in PP code that generates
the cases). In any case your code is inserted once for each PDL type into
this switch statement. The <CODE>$GENERIC()</CODE> macro just expands to the respective type in each copy of your parsed code
in this <CODE>switch</CODE>
statement, e.g., in the <CODE>case PDL_Byte</CODE> section <CODE>cur</CODE> will expand to
<CODE>PDL_Byte</CODE> and so on for the other case statements. I guess you realise that this is a
useful macro to hold values of pdls in some code.


<P>

There are a couple of other qualifiers with similar effects as <CODE>int</CODE>. For your convenience there are the <CODE>float</CODE> and <CODE>double</CODE> qualifiers with analogous consequences on type conversions as <CODE>int</CODE>. Let's assume you have a <EM>very</EM> large array for which you want to compute row and column sums with an
equivalent of the <CODE>sumover</CODE> function. However, with the normal definition of <CODE>sumover</CODE> you might run into problems when your data is, e.g. of type short. A call
like


<P>

<PRE>  sumover($large_pdl,($sums = null));
</PRE>

<P>

will result in <CODE>$sums</CODE> be of type short and is therefore prone to overflow errors if <CODE>$large_pdl</CODE> is a very large array. On the other hand calling


<P>

<PRE>  @dims = $large_pdl-&gt;dims; shift @dims;
  sumover($large_pdl,($sums = zeroes(double,@dims)));
</PRE>

<P>

is not a good alternative either. Now we don't have overflow problems with
<CODE>$sums</CODE> but at the expense of a type conversion of <CODE>$large_pdl</CODE> to double, something bad if this is really a large pdl. That's where <CODE>double</CODE>
comes in handy:


<P>

<PRE>  pp_def('sumoverd',
         Pars =&gt; 'a(n); double [o] b()',
         Code =&gt; 'double tmp=0;
                  loop(n) %{ tmp += a(); %}
                  $b() = tmp;',
  );
</PRE>

<P>

This gets us around the type conversion and overflow problems. Again,
analogous to the <CODE>int</CODE> qualifier <CODE>double</CODE> results in <CODE>b</CODE> always being of type double regardless of the type of <CODE>a</CODE> without leading to a typeconversion of <CODE>a</CODE> as a side effect.


<P>

Finally, there are the <CODE>type+</CODE> qualifiers where type is one of <CODE>int</CODE>
or <CODE>float</CODE>. What shall that mean. Let's illustrate the <CODE>int+</CODE>
qualifier with the actual definition of sumover:


<P>

<PRE>  pp_def('sumover',
         Pars =&gt; 'a(n); int+ [o] b()',
         Code =&gt; '$GENERIC(b) tmp=0;
                  loop(n) %{ tmp += a(); %}
                  $b() = tmp;',
  );
</PRE>

<P>

As we had already seen for the <CODE>int</CODE>, <CODE>float</CODE> and <CODE>double</CODE>
qualifiers, a pdl marked with a <CODE>type+</CODE> qualifier does not influence the datatype of the pdl operation. Its meaning
is ``make this pdl at least of type <CODE>type</CODE> or higher, as required by the type of the operation''. In the sumover
example this means that when you call the function with an <CODE>a</CODE> of type PDL_Short the output pdl will be of type PDL_Long (just as would
have been the case with the <CODE>int</CODE>
qualifier). This again tries to avoid overflow problems when using small
datatypes (e.g. byte images). However, when the datatype of the operation
is higher than the type specified in the <CODE>type+</CODE> qualifier
<CODE>b</CODE> will be created with the datatype of the operation, e.g. when
<CODE>a</CODE> is of type double then <CODE>b</CODE> will be double as well. We hope you agree that this is sensible behaviour
for <CODE>sumover</CODE>. It should be obvious how the <CODE>float+</CODE> qualifier works by analogy. It may become necessary to be able to specify a
set of alternative types for the parameters. However, this will probably
not be implemented until someone comes up with a reasonable use for it.


<P>

Note that we now had to specify the <CODE>$GENERIC</CODE> macro with the name of the pdl to derive the type from that argument. Why
is that? If you carefully followed our explanations you will have realised
that in some cases <CODE>b</CODE> will have a different type than the type of the operation. Calling the
'$GENERIC' macro with <CODE>b</CODE> as argument makes sure that the type will always the same as that of <CODE>b</CODE> in that part of the generic loop.


<P>

This is about all there is to say about the <A HREF="#item_Pars">Pars</A> section in a
<CODE>pp_def</CODE> call. You should remember that this section defines the <EM>signature</EM>
of a PP defined function, you can use several options to qualify certain
arguments as output and temporary args and all dimensions that you can
later refer to in the <A HREF="#item_Code">Code</A> section are defined by name.


<P>

It is important that you understand the meaning of the signature since in
the latest PDL versions you can use it to define threaded functions from
within perl, i.e. what we call <EM>perl level threading</EM>. Please check
<EM>PDL/Indexing</EM> for details.


<P>

<P>
<HR>
<H2><A NAME="The_C_Code_section">The <A HREF="#item_Code">Code</A> section

</A></H2>
The <A HREF="#item_Code">Code</A> section contains the actual XS code that will be in the innermost part of a
threadloop (if you don't know what a thread loop is then you still haven't
read <EM>PDL/Indexing</EM>; do it now ;) after any PP macros (like <CODE>$GENERIC</CODE>) and PP functions have been expanded (like the 
<A HREF="#item_loop">loop</A> function we are going to explain next).


<P>

Let's quickly reiterate the <CODE>sumover</CODE> example:


<P>

<PRE>  pp_def('sumover',
         Pars =&gt; 'a(n); int+ [o] b()',
         Code =&gt; '$GENERIC(b) tmp=0;
                  loop(n) %{ tmp += a(); %}
                  $b() = tmp;',
  );
  
</PRE>

<P>

The <A HREF="#item_loop">loop</A> construct in the <A HREF="#item_Code">Code</A> section also refers to the dimension name so you don't need to specify any
limits: the loop is correctly sized and everything is done for you, again.  


<P>

Next, there is the surprising fact that <CODE>$a()</CODE> and <CODE>$b()</CODE> do <STRONG>not</STRONG>
contain the index. This is not necessary because we're looping over
<EM>n</EM> and both variables know which dimensions they have so they automatically
know they're being looped over.


<P>

This feature comes in very handy in many places and makes for much shorter
code. Of course, there are times when you want to circumvent this; here is
a function which symmetrizes a matrix and serves as an example of how to
code explicit looping:


<P>

<PRE>        pp_def('symm',
                Pars =&gt; 'a(n,n); [o]c(n,n);',
                Code =&gt; 'loop(n) %{
                                int n2;
                                for(n2=n; n2&lt;$SIZE(n); n2++) {
                                        $c(n0 =&gt; n, n1 =&gt; n2) =
                                        $c(n0 =&gt; n2, n1 =&gt; n) =
                                         $a(n0 =&gt; n, n1 =&gt; n2);
                                }
                        %}
                '
        );
</PRE>

<P>

Let's dissect what is happening. Firstly, what is this function supposed to
do? From its signature you see that it takes a 2D matrix with equal numbers
of columns and rows and outputs a matrix of the same size. From a given
input matrix <CODE>$a</CODE> it computes a symmetric output matrix
<CODE>$c</CODE> (symmetric in the matrix sense that A^T = A where ^T means
matrix transpose, or in PDL parlance <CODE>$c</CODE> == $c-&gt;xchg(0,1)).
It does this by using only the values on and below the diagonal of $a. In
the output matrix <CODE>$c</CODE> all values on and below the diagonal are
the same as those in <CODE>$a</CODE> while those above the diagonal are a
mirror image of those below the diagonal (above and below are here
interpreted in the way that PDL prints 2D pdls). If this explanation still
sounds a bit strange just go ahead, make a little file into which you write
this definition, build the new PDL extension (see section on Makefiles for
PP code) and try it out with a couple of examples.


<P>

Having explained what the function is supposed to do there are a couple of
points worth noting from the syntactical point of view. First, we get the
size of the dimension named <CODE>n</CODE> again by using the <CODE>$SIZE</CODE> macro. Second, there are suddenly these funny <CODE>n0</CODE>
and <CODE>n1</CODE> index names in the code though the signature defines only the dimension <CODE>n</CODE>. Why this? The reason becomes clear when you note that both the first and
second dimension of <CODE>$a</CODE> and <CODE>$b</CODE> are named <CODE>n</CODE>
in the signature of <CODE>symm</CODE>. This tells PDL::PP that the first and second dimension of these arguments
should have the same size. Otherwise the generated function will raise a
runtime error. However, now in an access to <CODE>$a</CODE> and <CODE>$c</CODE> PDL::PP cannot figure out which index <CODE>n</CODE> refers to any more just from the name of the index. Therefore, the indices
with equal dimension names get numbered from left to right starting at 0,
e.g. in the above example <CODE>n0</CODE> refers to the first dimension of <CODE>$a</CODE> and <CODE>$c</CODE>, <CODE>n1</CODE> to the second and so on.


<P>

In all examples so far, we have only used the <A HREF="#item_Pars">Pars</A> and <A HREF="#item_Code">Code</A>
members of the hash that was passed to <CODE>pp_def</CODE>. There are certainly other keys that are recognised by PDL::PP and we will
hear about some of them in the course of this document. Find a
(non-exhaustive) list of keys in Appendix A. A list of macros and
PPfunctions (we have only encountered some of those in the examples above
yet) that are expanded in values of the hash argument to <CODE>pp_def</CODE> is summarised in Appendix B.


<P>

At this point, it might be appropriate to mention that PDL::PP is not a
completely static, well designed set of routines (as Tuomas puts it: ``stop
thinking of PP as a set of routines carved in stone'') but rather a
collection of things that the PDL::PP author (Tuomas J. Lukka) considered
he would have to write often into his PDL extension routines. PP tries to
be expandable so that in the future, as new needs arise, new common code
can be abstracted back into it. If you want to learn more on why you might
want to change PDL::PP and how to do it check the section on PDL::PP
internals.


<P>

<P>
<HR>
<H2><A NAME="Interfacing_your_own_library_fun">Interfacing your own/library functions using PP

</A></H2>
Now, consider the following: you have your own C function (that may in fact
be part of some library you want to interface to PDL) which takes as
arguments two pointers to vectors of double:


<P>

<PRE>        void myfunc(int n,double *v1,double *v2);
</PRE>

<P>

The correct way of defining the PDL function is


<P>

<PRE>        pp_def('myfunc',
                Pars =&gt; 'a(n); [o]b(n);',
                GenericTypes =&gt; [D],
                Code =&gt; 'myfunc($SIZE(n),$P(a),$P(b));'
        );
</PRE>

<P>

The <CODE>$P(</CODE><EM>par</EM><CODE>)</CODE> syntax returns a pointer to the first element and the other elements are
guaranteed to lie after that.


<P>

Notice that here it is possible to make many mistakes. First,
<CODE>$SIZE(n)</CODE> must be used instead of <CODE>n</CODE>. Second, you shouldn't put any loops in this code. Third, here we
encounter a new hash key recognised by PDL::PP : the <A HREF="#item_GenericTypes">GenericTypes</A> declaration tells PDL::PP to ONLY GENERATE THE TYPELOOP FOP THE LIST OF
TYPES SPECIFIED. In this case <CODE>double</CODE>. This has two advantages. Firstly the size of the compiled code is reduced
vastly, secondly if non-double arguments are passed to <CODE>myfunc()</CODE> PDL will automatically convert them to double before passing to the
external C routine and convert them back afterwards. 


<P>

One can also use <A HREF="#item_Pars">Pars</A> to qualify the types of individual arguments. Thus one could also write
this as: 


<P>

<PRE>        pp_def('myfunc',
                Pars =&gt; 'double a(n); double [o]b(n);',
                Code =&gt; 'myfunc($SIZE(n),$P(a),$P(b));'
        );
</PRE>

<P>

The type specification in <A HREF="#item_Pars">Pars</A> exempts the argument from variation in the typeloop - rather it is
automatically converted too and from the type specified. This is obviously
useful in a more general example, e.g.:


<P>

<PRE>        void myfunc(int n,float *v1,long *v2);
</PRE>

<P>

<PRE>        pp_def('myfunc',
                Pars =&gt; 'float a(n); long [o]b(n);',
                GenericTypes =&gt; [F],
                Code =&gt; 'myfunc($SIZE(n),$P(a),$P(b));'
        );
</PRE>

<P>

Note we still use <A HREF="#item_GenericTypes">GenericTypes</A> to reduce the size of the type loop, obviously PP could in principle spot
this and do it automatically though the code has yet to attain that level
of sophistication!


<P>

Finally note when types are converted automatically one MUST use the <CODE>[o]</CODE> qualifier for output variables or you hard one changes will get optimised
away by PP!


<P>

If you interface a large library you can automate the interfacing even
further. Perl can help you <CODE>again(!)</CODE> in doing this. In many
libraries you have certain calling conventions. This can be exploited. In
short, you can write a little parser (which is really not difficult in
perl) that then generates the calls to <CODE>pp_def</CODE> from parsed descriptions of the functions in that library. For an example,
please check the <EM>Slatec</EM>
interface in the <CODE>Lib</CODE> tree of the PDL distribution. If you want to check (during debugging) which
calls to PP functions your perl code generated a little helper package
comes in handy which replaces the PP functions by identically named ones
that dump their arguments to stdout. 


<P>

Just say


<P>

<PRE>   perl -MPDL::PP::Dump myfile.pd
</PRE>

<P>

to see the calls to <CODE>pp_def</CODE> and friends. Try it with <EM>ops.pd</EM> and 
<EM>slatec.pd</EM>. If you're interested (or want to enhance it), the source is in
Basic/Gen/PP/Dump.pm


<P>

<P>
<HR>
<H2><A NAME="Other_macros_and_functions_in_th">Other macros and functions in the Code section

</A></H2>
Macros: So far we have encountered the <CODE>$SIZE</CODE>, <CODE>$GENERIC</CODE> and <CODE>$P</CODE> macros. Now we are going to quickly explain the other macros that are
expanded in the
<A HREF="#item_Code">Code</A> section of PDL::PP along with examples of their usage.


<P>

<DL>
<DT><STRONG><A NAME="item__T">$T

</A></STRONG><DD>
The <CODE>$T</CODE> macro is used for type switches. This is very useful when you have to use
different external (e.g. library) functions depending on the input type of
arguments. The general syntax is 


<P>

<PRE>        $Ttypeletters(type_alternatives)
</PRE>

<P>

where <CODE>typeletters</CODE> is a permutation of a subset of the letters
<CODE>BSULFD</CODE> which stand for Byte, Short, Ushort, etc. and
<CODE>type_alternatives</CODE> are the expansions when the type of the PP operation is equal to that
indicated by the respective letter. Let's illustrate this incomprehensible
description by an example. Assuming you have two C functions with
prototypes


<P>

<PRE>  void float_func(float *in, float *out);
  void double_func(double *in, double *out);
</PRE>

<P>

which do basically the same thing but one accepts float and the other
double pointers. You could interface them to PDL by defining a generic
function <CODE>foofunc</CODE> (which will call the correct function depending on the type of the
transformation):


<P>

<PRE>  pp_def('foofunc',
        Pars =&gt; ' a(n); [o] b();',
        Code =&gt; ' $TFD(float_func,double_func) ($P(a),$P(b));'
        GenericTypes =&gt; [F,D],
  );
</PRE>

<P>

Please note that you can't say


<P>

<PRE>       Code =&gt; ' $TFD(float,double)_func ($P(a),$P(b));'
</PRE>

<P>

since the <CODE>$T</CODE> macro expands with trailing spaces, analogously to C preprocessor macros.
The slightly longer form illustrated above is correct. If you really want
brevity, you can of course do


<P>

<PRE>        '$TBSULFD('.(join ',',map {&quot;long_identifier_name_$_&quot;}
                qw/byt short unseigned lounge flotte dubble/).');'
</PRE>

<P>

<DT><STRONG><A NAME="item__PP">$PP

</A></STRONG><DD>
The <CODE>$PP</CODE> macro is used for a so called <EM>physical pointer access</EM>. The
<EM>physical</EM> refers to some internal optimisations of PDL (for those who are familiar
with the PDL core we are talking about the vaffine optimisations). This
macro is mainly for internal use and you shouldn't need to use it in any of
your normal code.


<P>

<DT><STRONG><A NAME="item__COMP">$COMP (and the OtherPars section)

</A></STRONG><DD>
The <CODE>$COMP</CODE> macro is used to access non-pdl values in the code section. Its name is
derived from the implementation of transformations in PDL. The variables
you can refer to using <CODE>$COMP</CODE> are members of the ``compiled'' structure that represents the PDL
transformation in question but does not yet contain any information about
dimensions (for further details check <EM>PDL/Internals</EM>). However, you can treat
<CODE>$COMP</CODE> just as a black box without knowing anything about the implementation of
transformations in PDL. So when would you use this macro? Its main usage is
to access values of arguments that are declared in the <A HREF="#item_OtherPars">OtherPars</A> section of a <CODE>pp_def</CODE> definition. But then you haven't heard about the <A HREF="#item_OtherPars">OtherPars</A> key yet?! Let's have another example that illustrates typical usage of both
new features:


<P>

<PRE>  pp_def('pnmout',
        Pars =&gt; 'a(m)',
        OtherPars =&gt; &quot;char* fd&quot;,
        GenericTypes =&gt; [B,U,S,L],
        Code =&gt; 'PerlIO *fp;
                 IO *io;
</PRE>

<P>

<PRE>                 io = GvIO(gv_fetchpv($PRIV(fd),FALSE,SVt_PVIO));
                 if (!io || !(fp = IoIFP(io)))
                        croak(&quot;Can\'t figure out FP&quot;);
</PRE>

<P>

<PRE>                 if (PerlIO_write(fp,$P(a),len) != len)
                                croak(&quot;Error writing pnm file&quot;);
  ');
</PRE>

<P>

This function is used to write data from a pdl to a file. The file
descriptor is passed as a string into this function. This parameter does
not go into the <A HREF="#item_Pars">Pars</A> section since it cannot be usefully treated like a pdl but rather into the
aptly named <A HREF="#item_OtherPars">OtherPars</A> section. Parameters in the <A HREF="#item_OtherPars">OtherPars</A>
section follow those in the <A HREF="#item_Pars">Pars</A> section when invoking the function, i.e.


<P>

<PRE>   open FILE,&quot;&gt;out.dat&quot; or die &quot;couldn't open out.dat&quot;;
   pnmout($pdl,'FILE');
</PRE>

<P>

When you want to access this parameter inside the code section you have to
tell PP by using the <CODE>$PRIV</CODE> macro, i.e. you write
<CODE>$PRIV(fd)</CODE> as in the example. Otherwise PP wouldn't know that the
<CODE>fd</CODE> you are referring to is the same as that specified in the
<A HREF="#item_OtherPars">OtherPars</A> section.


<P>

Another use for the <A HREF="#item_OtherPars">OtherPars</A> section is to set a named dimension in the signature. Let's have an example
how that is done:


<P>

<PRE>  pp_def('setdim',
        Pars =&gt; '[o] a(n)',
        OtherPars =&gt; 'int ns =&gt; n',
        Code =&gt; 'loop(n) %{ $a() = n; %}',
  );
</PRE>

<P>

This says that the named dimension <CODE>n</CODE> will be initialised from the value of the <EM>other parameter</EM>  <CODE>ns</CODE> which is of integer type (I guess you have realised that we use the <CODE>CType From =&gt; named_dim</CODE> syntax). Now you can call this function in the usual way:


<P>

<PRE>  setdim(($a=null),5);
  print $a;
    [ 0 1 2 3 4 ]
</PRE>

<P>

Admittedly this function is not very useful but it demonstrates how it
works. If you call the function with an existing pdl and you don't need to
explicitly specify the size of <CODE>n</CODE> since PDL::PP can figure it out from the dimensions of the non-null pdl. In
that case you just give the dimension parameter as <CODE>-1</CODE>:


<P>

<PRE>  $a = hist($b);
  setdim($a,-1);
</PRE>

<P>

That should do it.


<P>

</DL>
The only PP function that we have used in the examples so far is <A HREF="#item_loop">loop</A>. Additionally, there are currently two other functions which are
recognised in the <A HREF="#item_Code">Code</A> section:


<P>

<DL>
<DT><STRONG><A NAME="item_threadloop">threadloop

</A></STRONG><DD>
As we heard above the signature of a PP defined function defines the
dimensions of all the pdl arguments involved in a <EM>primitive</EM> operation. However, you often call the functions that you defined with PP
with pdls that have more dimensions than those specified in the signature.
In this case the primitive operation is performed on all subslices of
appropriate dimensionality in what is called a <EM>threadloop</EM> (see also overview above and <EM>PDL/Indexing</EM>). Assuming you have some notion of this concept you will probably
appreciate that the operation specified in the code section should be
optimised since this is the tightest loop inside a threadloop. However, if
you revisit the example where we define the <CODE>pnmout</CODE> function, you will quickly realise that looking up the <CODE>IO</CODE> file descriptor in the inner threadloop is not very efficient when writing
a pdl with many rows. A better approach would be to look up the <CODE>IO</CODE> descriptor once outside the threadloop and use its value then inside the
tightest threadloop. This is exactly where the <A HREF="#item_threadloop">threadloop</A> function comes in handy. Here is an improved definition of <CODE>pnmout</CODE> which uses this function:


<P>

<PRE>  pp_def('pnmout',
        Pars =&gt; 'a(m)',
        OtherPars =&gt; &quot;char* fd&quot;,
        GenericTypes =&gt; [B,U,S,L],
        Code =&gt; 'PerlIO *fp;
                 IO *io;
                 int len;
</PRE>

<P>

<PRE>                 io = GvIO(gv_fetchpv($PRIV(fd),FALSE,SVt_PVIO));
                 if (!io || !(fp = IoIFP(io)))
                        croak(&quot;Can\'t figure out FP&quot;);
</PRE>

<P>

<PRE>                 len = $SIZE(m) * sizeof($GENERIC());
</PRE>

<P>

<PRE>                 threadloop %{
                    if (PerlIO_write(fp,$P(a),len) != len)
                                croak(&quot;Error writing pnm file&quot;);
                 %}
  ');
</PRE>

<P>

This works as follows. Normally the C code you write inside the
<A HREF="#item_Code">Code</A> section is placed inside a threadloop (i.e., PP generates the appropriate
wrapping XS code around it). However, when you explicitly use the <A HREF="#item_threadloop">threadloop</A> function, PDL::PP recognises this and doesn't wrap your code with an
additional threadloop. This has the effect that code you write outside the
threadloop is only executed once per transformation and just the code with
in the surrounding <CODE>%{ ... %}</CODE>
pair is placed within the tightest threadloop. This also comes in handy
when you want to perform a decision (or any other code, especially CPU
intensive code) only once per thread, i.e.


<P>

<PRE>  pp_addhdr('
    #define RAW 0
    #define ASCII 1
  ');
  pp_def('do_raworascii',
         Pars =&gt; 'a(); b(); [o]c()',
         OtherPars =&gt; 'int mode',
         Code =&gt; ' switch ($PRIV(mode)) {
                    case RAW:
                        threadloop %{
                            /* do raw stuff */
                        %}
                        break;
                    case ASCII:
                        threadloop %{
                            /* do ASCII stuff */
                        %}
                        break;
                    default:
                        croak(&quot;unknown mode&quot;);
                   }'
   );
</PRE>

<P>

<DT><STRONG><A NAME="item_types">types

</A></STRONG><DD>
The types function works similar to the <CODE>$T</CODE> macro. However, with the 
<A HREF="#item_types">types</A> function the code in the following block (delimited by <CODE>%{</CODE>
and <CODE>%}</CODE> as usual) is executed for all those cases in which the datatype of the
operation is <EM>any of</EM> the types represented by the letters in the argument to <CODE>type</CODE>, e.g.


<P>

<PRE>     Code =&gt; '...
</PRE>

<P>

<PRE>             types(BSUL) %{
                 /* do integer type operation */
             %}
             types(FD) %{
                 /* do floating point operation */
             %}
             ...'
</PRE>

<P>

</DL>
<P>
<HR>
<H2><A NAME="Other_useful_PP_keys_in_data_ope">Other useful PP keys in data operation definitions

</A></H2>
You have already heard about the <A HREF="#item_OtherPars">OtherPars</A> key. Currently, there are not many other keys for a data operation that
will be useful in normal (whatever that is) PP programming. In fact, it
would be interesting to hear about a case where you think you need more
than what is provided at the moment. Please speak up on one of the PDL
mailing lists. Most other keys recognised by <CODE>pp_def</CODE> are only really useful for what we call <EM>slice operations</EM>
(see also above).


<P>

One thing that is strongly being planned is variable number of arguments,
which will be a little tricky.


<P>

<P>
<HR>
<H2><A NAME="Other_PDL_PP_functions_to_suppo">Other PDL::PP functions to support concise package definition

</A></H2>
So far, we have described the <CODE>pp_def</CODE> and <CODE>pp_done</CODE> functions. PDL::PP exports a few other functions to aid you in writing
concise PDL extension package definitions.


<P>

Often when you interface library functions as in the above example you have
to include additional C include files. Since the XS file is generated by PP
we need some means to make PP insert the appropriate include directives in
the right place into the generated XS file. To this end there is the <CODE>pp_addhdr</CODE> function. This is also the function to use when you want to define some C
functions for internal use by some of the XS functions (which are mostly
functions defined by <CODE>pp_def</CODE>). By including these functions here you make sure that PDL::PP inserts
your code before the point where the actual XS module section begins and
will therefore be left untouched by xsubpp (cf. <EM>perlxs</EM> and <EM>perlxstut</EM>
manpages).


<P>

A typical call would be


<P>

<PRE>  pp_addhdr('
  #include &lt;unistd.h&gt;       /* we need defs of XXXX */
  #include &quot;libprotos.h&quot;    /* prototypes of library functions */
  #include &quot;mylocaldecs.h&quot;  /* Local decs */
</PRE>

<P>

<PRE>  static void do_the real_work(PDL_Byte * in, PDL_Byte * out, int n)
  {
        /* do some calculations with the data */
  }   
  ');
</PRE>

<P>

This ensures that all the constants and prototypes you need will be
properly included and that you can use the internal functions defined here
in the
<CODE>pp_def</CODE>s, e.g.:


<P>

<PRE>  pp_def('barfoo',
         Pars =&gt; ' a(n); [o] b(n)',
         GenericTypes =&gt; '[B]',
         Code =&gt; ' int ns = $SIZE(n);
                   do_the_real_work($P(a),$P(b),ns);
                 ',
  );
</PRE>

<P>

In many cases the actual PP code (meaning the arguments to <CODE>pp_def</CODE>
calls) is only part of the package you are currently implementing. Often
there is additional perl code and XS code you would normally have written
into the pm and XS files which are now automatically generated by PP. So
how to get this stuff into those dynamically generated files? Fortunately,
there are a couple of functions, generally called <CODE>pp_addXXX</CODE> that assist you in doing this.


<P>

Let's assume you have additional perl code that should go into the
generated <STRONG>pm</STRONG>-file. This is easily achieved with the <CODE>pp_addpm</CODE> command:


<P>

<PRE>   pp_addpm(&lt;&lt;'EOD');
</PRE>

<P>

<PRE>   =head1 NAME
</PRE>

<P>

<PRE>   PDL::Lib::Mylib -- a PDL interface to the Mylib library
</PRE>

<P>

<PRE>   =head1 DESCRIPTION
</PRE>

<P>

<PRE>   This package implements an interface to the Mylib package with full
   threading and indexing support (see L&lt;PDL::Indexing&gt;).
</PRE>

<P>

<PRE>   =cut
</PRE>

<P>

<PRE>   use PGPLOT;
</PRE>

<P>

<PRE>   =head2 use_myfunc
        this function applies the myfunc operation to all the
        elements of the input pdl regardless of dimensions
        and returns the sum of the result
   =cut
</PRE>

<P>

<PRE>   sub use_myfunc {
        my $pdl = shift;
        
        myfunc($pdl-&gt;clump(-1),($res=null));
</PRE>

<P>

<PRE>        return $res-&gt;sum;
   }
</PRE>

<P>

<PRE>   EOD
</PRE>

<P>

You have probably got the idea. In some cases you also want to export your
additional functions. To avoid getting into trouble with PP which also
messes around with the <CODE>@EXPORT</CODE> array you just tell PP to add your functions to the list of exported
functions:


<P>

<PRE>  pp_add_exported('', 'use_myfunc gethynx');
</PRE>

<P>

Note the initial empty string argument (reason for it?).


<P>

Similar as the <CODE>pp_add_exported</CODE> function works the <CODE>pp_add_isa</CODE>
command. As the name already tells you <CODE>pp_add_isa</CODE> adds its arguments to the <CODE>@ISA</CODE> list so that you can say, e.g.


<P>

<PRE>  pp_add_isa(' Some::Other::Class ');
</PRE>

<P>

Sometimes you want to add extra XS code of your own (that is generally not
involved with any threading/indexing issues but supplies some other
functionality you want to access from the perl side) to the generated XS
file, for example


<P>

<PRE>  pp_addxs('','
</PRE>

<P>

<PRE>  # Determine endianness of machine
</PRE>

<P>

<PRE>  int
  isbigendian()
     CODE:
       unsigned short i;
       PDL_Byte *b;
</PRE>

<P>

<PRE>       i = 42; b = (PDL_Byte*) (void*) &amp;i;
  
       if (*b == 42) 
          RETVAL = 0;
       else if (*(b+1) == 42) 
          RETVAL = 1;
       else
          croak(&quot;Impossible - machine is neither big nor little endian!!\n&quot;);
       OUTPUT:
         RETVAL
  ');
</PRE>

<P>

Especially <CODE>pp_add_exported</CODE> and <CODE>pp_addxs</CODE> should be used with care. PP uses PDL::Exporter, hence letting PP export
your function means that they get added to the standard list of function
exported by default (the list defined by the export tag ``:Func''). If you
use <CODE>pp_addxs</CODE> you shouldn't try to do anything that involves threading or indexing
directly. PP is much better at generating the appropriate code from your
definitions.


<P>

Finally, you may want to add some code to the BOOT section of the XS file
(if you don't know what that is check <EM>perlxs</EM>). This is easily done with the <CODE>pp_add_boot</CODE> command:


<P>

<PRE>  pp_add_boot(&lt;&lt;EOB);
        descrip = mylib_initialize(KEEP_OPEN);
</PRE>

<P>

<PRE>        if (descrip == NULL)
           croak(&quot;Can't initialize library&quot;);
</PRE>

<P>

<PRE>        GlobalStruc-&gt;descrip = descrip;
        GlobalStruc-&gt;maxfiles = 200;
  EOB
</PRE>

<P>

<P>
<HR>
<H2><A NAME="Slice_operation">Slice operation

</A></H2>
The slice operation section of this manual is provided using dataflow and
lazy evaluation: when you need it, ask Tjl to write it. a delivery in a
week from when I receive the email is 95% probable and two week delivery is
99% probable.


<P>

And anyway, the slice operations require a much more intimate knowledge of
PDL internals than the data operations. Furthermore, the complexity of the
issues involved is considerably higher than that in the average data
operation. If you would like to convince yourself of this fact take a look
at the <CODE>Basic/Slices/slices.pd</CODE> file in the PDL distribution :-). Nevertheless, functions generated using
the slice operations are at the heart of the index manipulation and
dataflow capabilities of PDL.


<P>

Also, there are a lot of dirty issues with virtual piddles and vaffines
which we shall entirely skip here.


<P>

<P>
<HR>
<H2><A NAME="Makefiles_for_PP_files">Makefiles for PP files

</A></H2>
If you are going to generate a package from your PP file (typical file
extensions are <CODE>.pd</CODE> or <CODE>.pp</CODE> for the files containing PP code) it is easiest and safest to leave
generation of the appropriate commands to the Makefile. In the following we
will outline the typical format of a perl Makefile to automatically build
and install your package from a description in a PP file. Most of the rules
to build the xs, pm and other required files from the PP file are already
predefined in the PDL::Core::Dev package. We just have to tell MakeMaker to
use it. 


<P>

In most cases you can define your Makefile like


<P>

<PRE>  # Makefile.PL for a package defined by PP code.
</PRE>

<P>

<PRE>  use PDL::Core::Dev;            # Pick up development utilities
  use ExtUtils::MakeMaker;
</PRE>

<P>

<PRE>  $package = [&quot;mylib.pd&quot;,Mylib,PDL::Lib::Mylib];  
  %hash = pdlpp_stdargs($package);
  $hash{OBJECT} .= ' additional_Ccode$(OBJ_EXT) ';
  $hash{clean}-&gt;{FILES} .= ' todelete_Ccode$(OBJ_EXT) '; 
  $hash{'VERSION_FROM'} = 'mylib.pd';
  WriteMakefile(%hash);
</PRE>

<P>

<PRE>  sub MY::postamble { pdlpp_postamble($package); }  
</PRE>

<P>

Here, the list in <CODE>$package</CODE> is: first: PP source file name,
then the prefix for the produced files and finally the whole package name.
You can modify the hash in whatever way you like but it would be reasonable
to stay within some limits so that your package will continue to work with
later versions of PDL.


<P>

If you don't want to use prepackaged arguments, here is a generic
Makefile.PL that you can adapt for your own needs:


<P>

<PRE>  # Makefile.PL for a package defined by PP code.
</PRE>

<P>

<PRE>  use PDL::Core::Dev;            # Pick up development utilities
  use ExtUtils::MakeMaker;
</PRE>

<P>

<PRE>  WriteMakefile(
   'NAME'       =&gt; 'PDL::Lib::Mylib',
   'VERSION_FROM'       =&gt; 'mylib.pd',
   'TYPEMAPS'     =&gt; [&amp;PDL_TYPEMAP()], 
   'OBJECT'       =&gt; 'mylib$(OBJ_EXT) additional_Ccode$(OBJ_EXT)',
   'PM'         =&gt; { 'Mylib.pm'            =&gt; '$(INST_LIBDIR)/Mylib.pm'},
   'INC'          =&gt; &amp;PDL_INCLUDE(), # add include dirs as required by your lib
   'LIBS'         =&gt; [''],   # add link directives as necessary
   'clean'        =&gt; {'FILES'  =&gt; 
                          'Mylib.pm Mylib.xs Mylib$(OBJ_EXT)
                          additional_Ccode$(OBJ_EXT)'},
  );
</PRE>

<P>

<PRE>  # Add genpp rule; this will invoke PDL::PP on our PP file
  # the argument is an array reference where the array has three string elements:
  #   arg1: name of the source file that contains the PP code
  #   arg2: basename of the xs and pm files to be generated  
  #   arg3: name of the package that is to be generated
  sub MY::postamble { pdlpp_postamble([&quot;mylib.pd&quot;,Mylib,PDL::Lib::Mylib]); }  
To make life even easier PDL::Core::Dev defines the function C&lt;pdlpp_stdargs&gt;
that returns a hash with default values that can be passed (either
directly or after appropriate modification) to a call to WriteMakefile.
Currently, C&lt;pdlpp_stdargs&gt; returns a hash where the keys are filled in
as follows:
</PRE>

<P>

<PRE>        (
         'NAME'         =&gt; $mod,
         'TYPEMAPS'     =&gt; [&amp;PDL_TYPEMAP()], 
         'OBJECT'       =&gt; &quot;$pref\$(OBJ_EXT)&quot;,           
         PM     =&gt; {&quot;$pref.pm&quot; =&gt; &quot;\$(INST_LIBDIR)/$pref.pm&quot;},
         MAN3PODS =&gt; {&quot;$src&quot; =&gt; &quot;\$(INST_MAN3DIR)/$mod.\$(MAN3EXT)&quot;},
         'INC'          =&gt; &amp;PDL_INCLUDE(),
         'LIBS'         =&gt; [''],
         'clean'        =&gt; {'FILES'  =&gt; &quot;$pref.xs $pref.pm $pref\$(OBJ_EXT)&quot;},
        )
</PRE>

<P>

Here, <CODE>$src</CODE> is the name of the source file with PP code, <CODE>$pref</CODE> the prefix for the generated .pm and .xs files and <CODE>$mod</CODE> the name of the exntension module to generate.


<P>

<P>
<HR>
<H2><A NAME="INTERNALS">INTERNALS

</A></H2>
The internals of the current version consist of a large table which gives
the rules according to which things are translated and the subs which
implement these rules.


<P>

Later on, it would be good to make the table modifiable by the user so that
different things may be tried.


<P>

[Meta comment: here will hopefully be more in the future; currently, your
best bet will be to read the source code :-( or ask on the list (try the
latter first) ]


<P>

<P>
<HR>
<H1><A NAME="Appendix_A_Some_keys_recognised">Appendix A: Some keys recognised by PDL::PP

</A></H1>
Unless otherwise specified, the arguments are strings.


<P>

<DL>
<DT><STRONG><A NAME="item_Pars">Pars

</A></STRONG><DD>
define the signature of your function


<P>

<DT><STRONG><A NAME="item_OtherPars">OtherPars

</A></STRONG><DD>
arguments which are not pdls. Default: nothing.


<P>

<DT><STRONG><A NAME="item_Code">Code

</A></STRONG><DD>
the actual code that implements the functionality; several PP macros and PP
functions are recognised in the string value


<P>

<DT><STRONG><A NAME="item_GenericTypes">GenericTypes

</A></STRONG><DD>
An array reference. The array may contain any subset of the strings `B',
`S', `U', `L', `F' and `D', which specify which types your operation will
accept. This is very useful (and important!) when interfacing an external
library. Default: [qw/B S U L F D/]


<P>

<DT><STRONG><A NAME="item_Doc">Doc

</A></STRONG><DD>
Used to specify a documentation string in Pod format. See PDL::Doc for
information on PDL documentation conventions. Note: in the special case
where the PP 'Doc' string is one line this is implicitly used for the quick
reference AND the documentation!


<P>

If the Doc field is omitted PP will generate default documentation (after
all it knows about the Signature).


<P>

If you really want the function NOT to be documented in any way at this
point (e.g. for an internal routine, or because youu are doing it elsewhere
in the code) explictly specify <A HREF="#item_Doc_">Doc=</A>undef&gt;.


<P>

</DL>
<P>
<HR>
<H1><A NAME="Appendix_B_PP_macros_and_functi">Appendix B: PP macros and functions

</A></H1>
<P>
<HR>
<H2><A NAME="Macros">Macros

</A></H2>
<DL>
<DT><STRONG><A NAME="item__arr_">$arr()

</A></STRONG><DD>
access a pdl (by name) that was specified in the signature


<P>

<DT><STRONG><A NAME="item__COMP_x_">$COMP(x)

</A></STRONG><DD>
access a value in the private data structure of this transformation (mainly
used to use an argument that is specified in the <CODE>OtherPar</CODE> section)


<P>

<DT><STRONG><A NAME="item__SIZE_n_">$SIZE(n)

</A></STRONG><DD>
replaced at runtime by the actual size of a <EM>named</EM> dimension (as specified in the <EM>signature</EM>)


<P>

<DT><STRONG><A NAME="item__GENERIC_">$GENERIC()

</A></STRONG><DD>
replaced by the C type that is equal to the runtime type of the operation


<P>

<DT><STRONG><A NAME="item__P_a_">$P(a)

</A></STRONG><DD>
a pointer access to the PDL named <CODE>a</CODE> in the signature. Useful for interfacing to C functions


<P>

<DT><STRONG><A NAME="item__PP_a_">$PP(a)

</A></STRONG><DD>
a physical pointer access to pdl <CODE>a</CODE>; mainly for internal use


<P>

<DT><STRONG><A NAME="item__TXXX_Alternative_Alternative_">$TXXX(Alternative,Alternative)

</A></STRONG><DD>
expansion alternatives according to runtime type of operation, where XXX is
some string that is matched by /[BSULFD+]/.


<P>

</DL>
<P>
<HR>
<H2><A NAME="functions">functions

</A></H2>
<DL>
<DT><STRONG><A NAME="item_loop">loop(DIMS) %{ ... %}
 
loop over named dimensions; limits are generated automatically by PP

</A></STRONG><DD>
<DT><STRONG>threadloop %{ ... %}

</A></STRONG><DD>
enclose following code in a threadloop


<P>

<DT><STRONG><A NAME="item_types">types(TYPES) %{ ... %}

</A></STRONG><DD>
execute following code if type of operation is any of <CODE>TYPES</CODE>




<P>

</DL>
<EM>PDL</EM>




<P>

For the concepts of threading and slicing check <EM>PDL/Indexing</EM>.


<P>

<EM>PDL/Internals</EM>




<P>

<EM>perlxs</EM>, <EM>perlxstut</EM>




<P>

<P>
<HR>
<H1><A NAME="CURRENTLY_UNDOCUMENTED">CURRENTLY UNDOCUMENTED

</A></H1>
RedoDimsCode, $RESIZE()


<P>

<P>
<HR>
<H1><A NAME="BUGS">BUGS

</A></H1>
PDL::PP is still, even in its rewritten form, too complicated. It needs to
be rethought a little as well as deconvoluted and modularized some more
(e.g. all the NS things).


<P>

After the rewrite, this can happen a little by little, though.


<P>

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>
<CODE>Copyright(C)</CODE> 1997 Tuomas J. Lukka <A
HREF="MAILTO:(lukka@fas.harvard.edu),">(lukka@fas.harvard.edu),</A> Karl
Glaazebrook <A
HREF="MAILTO:(kgb@aaocbn1.aao.GOV.AU)">(kgb@aaocbn1.aao.GOV.AU)</A> and
Christian Soeller <A
HREF="MAILTO:(csoelle@sghms.ac.uk).">(csoelle@sghms.ac.uk).</A> All rights
reserved. Although destined for release as a man page with the standard PDL
distribution, it is not public domain. Permission is granted to freely
distribute verbatim copies of this document provided that no modifications
outside of formatting be made, and that this notice remain intact. You are
permitted and encouraged to use its code and derivatives thereof in your
own source code for fun or for profit as you see fit.


<P>

</DL>
    </BODY>

    </HTML>
