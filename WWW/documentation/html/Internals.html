    <HTML> 
	<HEAD> 
	    <TITLE>PDL::Internals - description of the current internals

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#Intro">Intro</A>
		<LI><A HREF="#Piddles">Piddles</A>
		<LI><A HREF="#Transformations">Transformations</A>
		<LI><A HREF="#Freeing">Freeing</A>
		<LI><A HREF="#Threading">Threading</A>
	</UL>

	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME

</A></H1>
PDL::Internals - description of the current internals


<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
<P>
<HR>
<H2><A NAME="Intro">Intro

</A></H2>
This document explains various aspects of the current implementation of
PDL. If you just want to use PDL for something, you definitely do not need
to read this. Even if you want to interface your C routines to PDL or
create new PDL::PP functions, you do not need to read this (though it may
be informative). This document is primarily intended for people interested
in debugging or changing the internals of PDL. To read this, a good
understanding of the C language and programming and data structures in
general is required, as well as some perl understanding. If you read
through this document and understand all of it and are able to point what
any part of this document refers to in the PDL core sources and
additionally struggle to understand PDL::PP, you will be awarded the title
``PDL Guru'' (of course, the current version of this document is so
incomplete that this is not yet the case).


<P>

<STRONG>Warning:</STRONG> If it seems that this document has gotten out of date, please inform the
PerlDL developers email list (address in the README file) about it. This
may well happen.


<P>

<P>
<HR>
<H2><A NAME="Piddles">Piddles

</A></H2>
Currently, a pdl data object is a hash ref which contains the element PDL,
which is a pointer to a pdl structure, as well as some other fields. The
file Core.pm uses some of these fields and the file pdlhash.c converts
these to C when necessary.


<P>

The pdl struct is defined in pdl.h and the meanings of the fields are


<P>

<DL>
<DT><STRONG><A NAME="item_magicno">magicno

</A></STRONG><DD>
A magic number, used to check whether something really is a piddle when
debugging.


<P>

<DT><STRONG><A NAME="item_state">state

</A></STRONG><DD>
Various flags about the state of the pdl, such as whether the parents of
this pdl have been altered at some point.


<P>

<DT><STRONG><A NAME="item_trans">trans

</A></STRONG><DD>
Where this pdl was obtained from. This pointer may be null, in which case
this pdl is not getting any dataflow from anywhere. Note, however that
being non-null does not mean that data is flowing:


<P>

<PRE>        $a = pdl 2,3,4; $b = pdl 4,5,6;
        $c = $a + $b;     # Note: no dataflow (not asked for)
</PRE>

<P>

here, the trans field in <CODE>$c</CODE> contains a pointer to a
transformation. Only when <CODE>$a</CODE> or <CODE>$b</CODE> is changed, is
the transformation destroyed and the field cleared. To see whether data is
flowing, check the flags field of the trans struct.


<P>

<DT><STRONG><A NAME="item_vafftrans">vafftrans

</A></STRONG><DD>
This is intended for speeding up e.g. the chaining of affine
transformations. See <CODE>pdlapi.c</CODE> for the code handling this. Also, <CODE>slices.pd</CODE> defines some things with / for this.


<P>

<DT><STRONG><A NAME="item_sv">sv

</A></STRONG><DD>
Pointer to the hash object. May be null if this pdl does not have a perl
counterpart.


<P>

<DT><STRONG><A NAME="item_datasv">datasv, data

</A></STRONG><DD>
The field datasv is a pointer to the perl SV containing the data string.
These may be null before the pdl is finally physicalized.


<P>

<DT><STRONG><A NAME="item_nvals">nvals

</A></STRONG><DD>
How many values there are in data


<P>

<DT><STRONG><A NAME="item_datatype">datatype

</A></STRONG><DD>
The type of the data stored in the data vector.


<P>

<DT><STRONG><A NAME="item_dims">dims, ndims

</A></STRONG><DD>
The dimensions of this pdl. Remember to physicalize the pdl before using.


<P>

<DT><STRONG><A NAME="item_dimincs">dimincs

</A></STRONG><DD>
As an optimization, an increment for each dimension is stored here. In
contrast to previous alpha versions, these are required to correspond
exactly do dims. If you want to optimize for affine transformations, use
the trans or vtrans.


<P>

<DT><STRONG><A NAME="item_threadids">threadids, nthreadids

</A></STRONG><DD>
This is where the threading tags are stored. The way this works is that
ndims and dims hold <EM>all</EM> dimensions of the pdl, including threaded dimensions. The real dimensions
of the pdl extend from 0 to threadids[0]-1, the thread dimensions with id 0
extend from threadids[0] to threadids[1]-1 and the thread dimensions with
the last id extend from threadids[nthreadids-1] to threadids[nthreadids]-1.
For example, if a pdl has dimensions (2,3,4,5) (= 120 elements) and
nthreadids==2 and threadids={1,3,4}, there is one ``real'' dimensions with
size 2, two dimensions with threadid 0 (3 and 4) and the dimensions with
size 5 has threadid 1.


<P>

<DT><STRONG><A NAME="item_progenitor">progenitor, future_me

</A></STRONG><DD>
See the section on families below


<P>

<DT><STRONG><A NAME="item_children">children

</A></STRONG><DD>
The children of this pdl i.e. where data is flowing to from this pdl.


<P>

<DT><STRONG><A NAME="item_living_for">living_for

</A></STRONG><DD>
XXX Not quite clear right now. Has to do with families


<P>

<DT><STRONG><A NAME="item_def_">def_* 

</A></STRONG><DD>
To avoid mallocs, there is a suitable amount of space already allocated for
each pointer in this pdl, with the ideology that if you have more than
six-dimensional data you must be willing to settle for a little more
overhead.


<P>

<DT><STRONG><A NAME="item_magic">magic

</A></STRONG><DD>
If this pdl is magical (e.g. if it is bound to something), this pointer is
non-null and you must call the appropriate magic-handling routines when
using the pdl.


<P>

<DT><STRONG><A NAME="item_hdrsv">hdrsv

</A></STRONG><DD>
A ``header'' SV * that can be set and accessed from outside. Can be used to
include any perl object in a piddle.


<P>

<H2><A NAME="Transformations">Transformations

</A></H2>
Each transformation has a virtual table which contains various information
about that transformation. Usually transformations are generated with
PDL::PP so it's better to see that documentation.


<P>

<H2><A NAME="Freeing">Freeing

</A></H2>
Currently, not much is freed, especially when dataflow is done. This is
bound to change pretty soon.


<P>

<H2><A NAME="Threading">Threading

</A></H2>
The file pdlthread.c handles most of the threading matters. The threading
is encapsulated in the structure pdlthread.h.


<P>

<H1><A NAME="AUTHOR">AUTHOR

</A></H1>
<CODE>Copyright(C)</CODE> 1997 Tuomas J. Lukka <A
HREF="MAILTO:(lukka@fas.harvard.edu).">(lukka@fas.harvard.edu).</A>
Redistribution in the same form is allowed but reprinting requires a
permission from the author.


<P>

</DL>
</DL>
    </BODY>

    </HTML>
