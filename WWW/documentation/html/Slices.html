    <HTML> 
	<HEAD> 
	    <TITLE>PDL::Slices -- Stupid index tricks

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#FUNCTIONS">FUNCTIONS</A>
	<UL>

		<LI><A HREF="#affineinternal">affineinternal</A>
		<LI><A HREF="#identity">identity</A>
		<LI><A HREF="#index">index</A>
		<LI><A HREF="#index2d">index2d</A>
		<LI><A HREF="#flowconvert">flowconvert</A>
		<LI><A HREF="#converttypei">converttypei</A>
		<LI><A HREF="#clump">clump</A>
		<LI><A HREF="#xchg">xchg</A>
		<LI><A HREF="#mv">mv</A>
		<LI><A HREF="#oneslice">oneslice</A>
		<LI><A HREF="#slice">slice</A>
		<LI><A HREF="#affine">affine</A>
		<LI><A HREF="#diagonalI">diagonalI</A>
		<LI><A HREF="#lags">lags</A>
		<LI><A HREF="#splitdim">splitdim</A>
		<LI><A HREF="#threadI">threadI</A>
		<LI><A HREF="#identvaff">identvaff</A>
		<LI><A HREF="#unthread">unthread</A>
	</UL>

	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME

</A></H1>
PDL::Slices -- Stupid index tricks


<P>

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS

</A></H1>
<PRE>  use PDL;
  $a = ones(3,3);
  $b = $a-&gt;slice('-1:0,(1)');
  $c = $a-&gt;dummy(2);
</PRE>

<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
This package provides many of the powerful PerlDL core index manipulation
routines. These routines are usually two-way so you can get a unit matrix
by


<P>

<PRE>        $a = zeroes(1000,1000);
        $a-&gt;diagonal(0,1) ++;
</PRE>

<P>

which is usually fairly efficient. See <EM>pdlindexing</EM> and
<EM>pdltips</EM> for more examples.


<P>

These functions are usually two-way:


<P>

<PRE>        $b = $a-&gt;slice(&quot;1:3&quot;);
        $b += 5;                # $a is changed!
</PRE>

<P>

If you want to force a copy and no ``flow'' backwards, you need


<P>

<PRE>        $b = $a-&gt;slice(&quot;1:3&quot;)-&gt;copy;
        $b += 5;                # $a is not changed.
</PRE>

<P>

alternatively, you can use


<P>

<PRE>        $b = $a-&gt;slice(&quot;1:3&quot;)-&gt;sever;
</PRE>

<P>

which doesn't copy the struct but beware that after


<P>

<PRE>        $b = $a-&gt;slice(&quot;1:3&quot;);
        $c = $b-&gt;sever;
</PRE>

<P>

the variables <CODE>$b</CODE> and <CODE>$c</CODE> point to the same object
but with -&gt;copy they do not.


<P>

The fact that there is this kind of flow makes PDL a very powerful language
in many ways: since you can alter the original data by altering some
easier-to-use representation of it, many things are much easier to
accomplish, just like making the above unit matrix.


<P>

<P>
<HR>
<H1><A NAME="FUNCTIONS">FUNCTIONS

</A></H1>
<P>
<HR>
<H2><A NAME="affineinternal">affineinternal

</A></H2>
<PRE>  Signature: (P(); C())
</PRE>

<P>

internal


<P>

<P>
<HR>
<H2><A NAME="identity">identity

</A></H2>
<PRE>  Signature: (P(); C())
</PRE>

<P>

internal


<P>

<P>
<HR>
<H2><A NAME="index">index

</A></H2>
<PRE>  Signature: (a(n); int ind(); [oca] c())
</PRE>

<P>

These functions provide rudimentary index indirection.


<P>

<PRE>        c = a(ind());
        c = a(ind1(),ind2());
</PRE>

<P>

It would be useful to have a more complete function for this at some point,
or at least a perl wrapper, that allows


<P>

<PRE>        $c = $a-&gt;islice(&quot;1:2&quot;,$ind1,&quot;3:4&quot;,$ind2&quot;);
</PRE>

<P>

with many dimensions.  


<P>

This function is two-way, i.e. after


<P>

<PRE>        $c = $a-&gt;index(pdl[0,5,8]);
        $c .= pdl [0,2,4];
</PRE>

<P>

the changes in <CODE>$c</CODE> will flow back to $a.


<P>

<P>
<HR>
<H2><A NAME="index2d">index2d

</A></H2>
<PRE>  Signature: (a(na,nb); int inda(); int indb(); [oca] c())
</PRE>

<P>

These functions provide rudimentary index indirection.


<P>

<PRE>        c = a(ind());
        c = a(ind1(),ind2());
</PRE>

<P>

It would be useful to have a more complete function for this at some point,
or at least a perl wrapper, that allows


<P>

<PRE>        $c = $a-&gt;islice(&quot;1:2&quot;,$ind1,&quot;3:4&quot;,$ind2&quot;);
</PRE>

<P>

with many dimensions.  


<P>

This function is two-way, i.e. after


<P>

<PRE>        $c = $a-&gt;index(pdl[0,5,8]);
        $c .= pdl [0,2,4];
</PRE>

<P>

the changes in <CODE>$c</CODE> will flow back to $a.


<P>

<P>
<HR>
<H2><A NAME="flowconvert">flowconvert

</A></H2>
<PRE>  Signature: (PARENT(); [oca]CHILD(); int totype)
</PRE>

<P>

internal


<P>

<P>
<HR>
<H2><A NAME="converttypei">converttypei

</A></H2>
<PRE>  Signature: (P(); C(); int totype)
</PRE>

<P>

internal


<P>

<P>
<HR>
<H2><A NAME="clump">clump

</A></H2>
<PRE>  Signature: (P(); C(); int n)
</PRE>

<P>

``clumps'' the first n dimensions into one large dimension


<P>

If, for example, <CODE>$a</CODE> has dimensions (5,3,4) then after


<P>

<PRE>        $b = $a-&gt;clump(2);   # Clump 2 first dimensions
</PRE>

<P>

the variable <CODE>$b</CODE> will have dimensions (15,4) and the element
$b-&gt;at(7,3) refers to the element $a-&gt;at(1,2,3).


<P>

<P>
<HR>
<H2><A NAME="xchg">xchg

</A></H2>
<PRE>  Signature: (P(); C(); int n1; int n2)
</PRE>

<P>

exchange two dimensions


<P>

The command 


<P>

<PRE>        $b = $a-&gt;xchg(2,3);
</PRE>

<P>

creates <CODE>$b</CODE> to be like <CODE>$a</CODE> except that the
dimensions 2 and 3 are exchanged with each other i.e.


<P>

<PRE>        $b-&gt;at(5,3,2,8) == $a-&gt;at(5,3,8,2)
</PRE>

<P>

<P>
<HR>
<H2><A NAME="mv">mv

</A></H2>
<PRE>  Signature: (P(); C(); int n1; int n2)
</PRE>

<P>

move a dimension to another position


<P>

The command


<P>

<PRE>        $b = $a-&gt;mv(4,1);
</PRE>

<P>

creates <CODE>$b</CODE> to be like <CODE>$a</CODE> except that the
dimension 4 is moved to the place 1:


<P>

<PRE>        $b-&gt;at(1,2,3,4,5,6) == $a-&gt;at(1,5,2,3,4,6);
</PRE>

<P>

The other dimensions are moved accordingly.


<P>

<P>
<HR>
<H2><A NAME="oneslice">oneslice

</A></H2>
<PRE>  Signature: (P(); C(); int nth; int from; int step; int nsteps)
</PRE>

<P>

experimental function - not for public use


<P>

<PRE>  $a = oneslice();
</PRE>

<P>

This is not for public use currently. See the source if you have to. This
function can be used to accomplish run-time changing of transformations
i.e. changing the size of some piddle at run-time.


<P>

However, the mechanism is not yet finalized and this is just a
demonstration.


<P>

<P>
<HR>
<H2><A NAME="slice">slice

</A></H2>
<PRE>  Signature: (P(); C(); char* str)
</PRE>

<P>

Returns a rectangular slice of the original piddle 


<P>

<PRE>  $a-&gt;slice('1:3'); #  return the second to fourth elements of $a
</PRE>

<P>

The argument string is a comma-separated list of what to do for each
dimension. The current formats include the following (a,b and c are
integers):


<P>

<DL>
<DT><STRONG><A NAME="item__">":"

</A></STRONG><DD>
takes the whole dimension intact.


<P>

<DT><STRONG><A NAME="item__">""

</A></STRONG><DD>
(nothing) is a synonym for ``:'' (This means that <CODE>$a-&gt;slice(':,3')</CODE> is equal to $a-&gt;<CODE>slice(',3')).</CODE>


<P>

<DT><STRONG><A NAME="item__n_">"n"

</A></STRONG><DD>
slices only this value out of the corresponding dimension


<P>

<DT><STRONG><A NAME="item__n_">"(n)"

</A></STRONG><DD>
means the same as ``n'' by itself except that the resulting dimension of
length one is deleted (so if <CODE>$a</CODE> has dims (3,4,5) then
<CODE>$a-&gt;slice(':,(2),:')</CODE> has dimensions (3,5) whereas $a-&gt;<CODE>slice(':,2,:')</CODE> has dimensions (3,1,5)).


<P>

<DT><STRONG><A NAME="item__a_b_">"a:b"

</A></STRONG><DD>
slices the range <EM>a</EM> to <EM>b</EM> inclusive out of the dimension


<P>

<DT><STRONG><A NAME="item__a_b_c_">"a:b:c"

</A></STRONG><DD>
slices the range <EM>a</EM> to <EM>b</EM>, with step c (i.e. 3:7:2 gives the indices (3,5,7)). This may be confusing
to Matlab users but several other packages already use this syntax.


<P>

<DT><STRONG><A NAME="item__">"*"

</A></STRONG><DD>
inserts an extra dimension of width 1 and


<P>

<DT><STRONG><A NAME="item__a_">"*a"

</A></STRONG><DD>
inserts an extra (dummy) dimension of width <EM>a</EM>.


<P>

</DL>
An extension is planned for a later stage allowing
$a-&gt;slice('(=1),(=1|5:8),3:6(=1),4:6') to express a multidimensional
diagonal of $a.


<P>

<P>
<HR>
<H2><A NAME="affine">affine

</A></H2>
<PRE>  Signature: (P(); C(); int offspar; SV *dimlist; SV *inclist)
</PRE>

<P>

internal


<P>

<P>
<HR>
<H2><A NAME="diagonalI">diagonalI

</A></H2>
<PRE>  Signature: (P(); C(); SV *list)
</PRE>

<P>

Returns the multidimensional diagonal over the specified dimensions.


<P>

The diagonal is placed at the first (by number) dimension that is
diagonalized. The other diagonalized dimensions are removed. So if
<CODE>$a</CODE> has dimensions (5,3,5,4,6,5) then after


<P>

<PRE>        $b = $a-&gt;diagonal(0,2,5);
</PRE>

<P>

the piddle <CODE>$b</CODE> has dimensions (5,3,4,6) and $b-&gt;at(2,1,0,1)
refers to $a-&gt;at(2,1,2,0,1,2).


<P>

NOTE: diagonal doesn't handle threadids correctly. XXX FIX


<P>

<P>
<HR>
<H2><A NAME="lags">lags

</A></H2>
<PRE>  Signature: (P(); C(); int nthdim; int step; int n)
</PRE>

<P>

Returns a piddle of lags to parent.


<P>

I.e. if <CODE>$a</CODE> contains


<P>

<PRE>       [0,1,2,3,4,5,6,7]
</PRE>

<P>

then 


<P>

<PRE>        $b = $a-&gt;lags(0,2,2);
</PRE>

<P>

<PRE> is a (5,2) matrix
</PRE>

<P>

<PRE>       [2,3,4,5,6,7]
       [0,1,2,3,4,5]
</PRE>

<P>

This order of returned indices is kept because the function is called
``lags'' i.e. the nth lag is n steps behind the original.


<P>

<P>
<HR>
<H2><A NAME="splitdim">splitdim

</A></H2>
<PRE>  Signature: (P(); C(); int nthdim; int nsp)
</PRE>

<P>

Splits a dimension in the parent piddle (opposite of <CODE>clump</CODE>)


<P>

After


<P>

<PRE>        $b = $a-&gt;splitdim(2,3);
</PRE>

<P>

the expression 


<P>

<PRE>        $b-&gt;at(6,4,x,y,3,6) == $a-&gt;at(6,4,x+3*y)
</PRE>

<P>

is always true (x has to be less than 3).


<P>

<P>
<HR>
<H2><A NAME="threadI">threadI

</A></H2>
<PRE>  Signature: (P(); C(); int id; SV *list)
</PRE>

<P>

internal


<P>

Put some dimensions to a threadid.


<P>

<PRE>        $b = $a-&gt;threadI(0,1,5); # thread over dims 1,5 in id 1
</PRE>

<P>

<P>
<HR>
<H2><A NAME="identvaff">identvaff

</A></H2>
<PRE>  Signature: (P(); C())
</PRE>

<P>

A vaffine identity transformation (includes thread_id copying).


<P>

Mainly for internal use.


<P>

<P>
<HR>
<H2><A NAME="unthread">unthread

</A></H2>
<PRE>  Signature: (P(); C(); int atind)
</PRE>

<P>

All threaded dimensions are made real again.


<P>

See <EM>XXX</EM> for details and examples.


<P>

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>
Copyright (C) 1997 Tuomas J. Lukka. All rights reserved. There is no
warranty. You are allowed to redistribute this software / documentation
under certain conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution, the
copyright notice should be included in the file.


<P>

</DL>
    </BODY>

    </HTML>
